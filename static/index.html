<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G.Printer</title>
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .collapsible-content { display: none; }
        .collapsible-content.active { display: block; }
        .table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #ddd;
            border-radius: 0.375rem;
        }
        .table-container table { margin-top: 0; }
        .table-container thead th {
            position: sticky;
            top: 0;
            z-index: 10;
            background-color: #f2f2f2;
        }
        .show-more-btn {
            display: block;
            width: 100%;
            text-align: center;
            padding: 0.5rem;
            background-color: #3b82f6;
            color: white;
            border-radius: 0.375rem;
            margin-top: 0.5rem;
        }
        .show-more-btn:hover { background-color: #2563eb; }
        .date-range-container {
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .date-range-container.active { display: grid; }
        
        .sortable-header {
            cursor: pointer;
            position: relative;
            padding-right: 20px !important;
        }
        .sortable-header::after {
            content: "";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            opacity: 0.3;
        }
        .sortable-header.asc::after {
            border-bottom: 5px solid #333;
            opacity: 1;
        }
        .sortable-header.desc::after {
            border-top: 5px solid #333;
            opacity: 1;
        }
        .sortable-header:hover::after { opacity: 0.7; }
        
        .combo-box {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .combo-box input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 0.25rem;
        }
        .combo-box-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            z-index: 1000;
            display: none;
        }
        .combo-box-options.active { display: block; }
        .combo-box-option {
            padding: 0.5rem;
            cursor: pointer;
        }
        .combo-box-option:hover { background-color: #f0f0f0; }
        .combo-box-option.selected { background-color: #e0e0e0; }
        .combo-box-option.blank-option { font-style: italic; color: #666; }

        .section-header {
            background-color: #3b82f6;
            color: white;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            text-align: center;
        }

        .control-panel-section {
            background-color: white;
            padding: 0.5rem;
            border-radius: 0.375rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .date-range-active {
            background-color: #f0f9ff;
            border: 1px solid #3b82f6;
            border-radius: 0.25rem;
            padding: 0.25rem;
            font-size: 0.75rem;
            margin-top: 0.25rem;
            display: none;
        }

        .total-row td { font-weight: bold; background-color: #f0f0f0; }
        .subtotal-row td { font-weight: bold; background-color: #e0e0e0; text-align: right; }
        .final-total-row td { font-weight: bold; background-color: #d0d0d0; text-align: right; }
        .description-row td { font-style: italic; color: #666; }
        .amount-column { text-align: right; }
        .selected-row { background-color: #e6f7ff !important; }
        .row-checkbox { width: 18px; height: 18px; cursor: pointer; }
        .select-all-checkbox { margin-right: 5px; }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .toggle-container { display: flex; align-items: center; gap: 0.5rem; }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3b82f6;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider { background-color: #10b981; }
        input:checked + .toggle-slider:before { transform: translateX(32px); }
        .toggle-label { font-size: 0.875rem; color: #333; }
        
        .sheet-info {
            font-size: 0.75rem;
            margin-top: 0.5rem;
            padding: 0.25rem;
            background-color: #f8fafc;
            border-radius: 0.25rem;
        }
        .sheet-info-title { font-weight: 600; margin-bottom: 0.25rem; }
        .sheet-info-row { display: flex; justify-content: space-between; }

        .filter-history {
            margin-top: 1rem;
            padding: 0.5rem;
            background-color: #f8fafc;
            border-radius: 0.25rem;
            font-size: 0.75rem;
        }
        .filter-history-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }
        .filter-history-clear {
            color: #3b82f6;
            cursor: pointer;
            text-decoration: underline;
        }
    </style>
</head>
<body class="p-4 bg-gray-100">
    <h1 class="text-2xl font-bold mb-4">G Printer</h1>
    
    <div class="bg-white p-4 rounded shadow mb-6">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <div>
                <div class="section-header">Load File</div>
                <div class="control-panel-section">
                    <input type="file" id="fileInput" accept=".xlsx" class="text-sm w-full mb-2">
                    <button id="loadFile" class="bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600 w-full text-sm flex items-center justify-center gap-2">
                        <span id="loadButtonText">Upload</span>
                        <span id="loadSpinner" class="spinner hidden"></span>
                    </button>
                    <div id="sheetInfo" class="sheet-info hidden">
                        <div class="sheet-info-title">Sheets in uploaded file:</div>
                        <div class="sheet-info-row">
                            <span>Custom Report:</span>
                            <span id="customReportRows">0 rows</span>
                        </div>
                        <div class="sheet-info-row">
                            <span>Item Details:</span>
                            <span id="itemDetailsRows">0 rows</span>
                        </div>
                        <div class="sheet-info-row">
                            <span>Merged unique Data:</span>
                            <span id="mergedDataRows">0 rows</span>
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <div class="section-header">Search</div>
                <div class="control-panel-section">
                    <select id="nameColumn" class="border p-1 rounded w-full text-sm mb-2"></select>
                    <div id="textSearchContainer">
                        <div class="combo-box">
                            <input type="text" id="nameSearchInput" placeholder="Type to search or select..." class="border p-1 rounded w-full text-sm">
                            <div id="nameSearchDropdown" class="combo-box-options"></div>
                        </div>
                    </div>
                    <div id="dateRangeContainer" class="date-range-container">
                        <div>
                            <label class="text-xs">From:</label>
                            <input type="date" id="dateFrom" class="border p-1 rounded w-full text-sm">
                        </div>
                        <div>
                            <label class="text-xs">To:</label>
                            <input type="date" id="dateTo" class="border p-1 rounded w-full text-sm">
                        </div>
                    </div>
                    <div id="dateRangeActive" class="date-range-active hidden"></div>
                    <button id="searchByName" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 mt-2 w-full text-sm">
                        Apply Filter
                    </button>
                    <div id="filterHistory" class="filter-history hidden">
                        <div class="sheet-info-title">Active Filters:</div>
                        <div id="filterHistoryItems"></div>
                        <div class="filter-history-clear" id="clearFilters">Clear All Filters</div>
                    </div>
                </div>
            </div>

            <div>
                <div class="section-header">Select columns</div>
                <div class="control-panel-section">
                    <select id="columnSelect" multiple class="border p-2 rounded w-full text-sm h-16 mb-2"></select>
                    <button id="applyFilters" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 w-full text-sm">
                        Apply & Save
                    </button>
                </div>
            </div>
        </div>

        <div class="flex flex-wrap gap-2 mt-4 items-center">
            <div class="toggle-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="printToggle">
                    <span class="toggle-slider"></span>
                </label>
                <span id="printToggleLabel" class="toggle-label">Print All</span>
            </div>
            <button id="executePrint" class="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600 text-sm">
                View & Print
            </button>
        </div>
    </div>

    <h2 class="text-xl font-semibold mt-6">Filtered Rows</h2>
    <div class="table-container">
        <table id="matchingRowsTable" class="bg-white"></table>
    </div>
    <button id="showAllRows" class="show-more-btn hidden">Show All Rows</button>

    <script>
        let data = [];
        let headers = [];
        let filteredData = [];
        let showingAllRows = false;
        let originalData = [];
        let selectedColumns = [];
        let currentSortColumn = null;
        let sortDirection = 'asc';
        let selectedRows = new Set();
        let activeFilters = [];
        let currentWorkingData = [];
        let rowIndexMap = []; // This will map filtered row indices to original data indices

        // Load Excel File
        document.getElementById('loadFile').addEventListener('click', () => {
            const file = document.getElementById('fileInput').files[0];
            if (!file) {
                alert('Please select a file.');
                return;
            }

            const loadButtonText = document.getElementById('loadButtonText');
            const loadSpinner = document.getElementById('loadSpinner');
            const loadButton = document.getElementById('loadFile');
            
            loadButton.disabled = true;
            loadButtonText.textContent = 'Processing...';
            loadSpinner.classList.remove('hidden');

            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || 'Network response was not ok');
                    });
                }
                return response.json();
            })
            .then(responseData => {
                if (responseData.error) {
                    throw new Error(responseData.error);
                }

                data = responseData.data || [];
                headers = responseData.headers || (data.length > 0 ? Object.keys(data[0]) : []);
                
                if (data.length === 0) {
                    throw new Error('No data found in the processed file');
                }
                
                originalData = [...data];
                filteredData = [...data];
                currentWorkingData = [...data];
                selectedColumns = [...headers];
                showingAllRows = false;
                currentSortColumn = null;
                sortDirection = 'asc';
                selectedRows = new Set();
                activeFilters = [];
                updateFilterHistory();
                
                updateMatchingRowsTable();
                populateDropdowns();
                
                const sheetInfoDiv = document.getElementById('sheetInfo');
                sheetInfoDiv.classList.remove('hidden');
                document.getElementById('customReportRows').textContent = 
                    `${responseData.sheetStats?.customReportRows || 'N/A'} rows`;
                document.getElementById('itemDetailsRows').textContent = 
                    `${responseData.sheetStats?.itemDetailsRows || 'N/A'} rows`;
                document.getElementById('mergedDataRows').textContent = 
                    `${data.length} rows`;
                
                document.getElementById('printToggle').checked = false;
                document.getElementById('printToggleLabel').textContent = 'Print All';
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred: ' + error.message);
                
                data = [];
                headers = [];
                originalData = [];
                filteredData = [];
                currentWorkingData = [];
                selectedRows = new Set();
                activeFilters = [];
                updateFilterHistory();
                updateMatchingRowsTable();
                document.getElementById('sheetInfo').classList.add('hidden');
                document.getElementById('printToggle').checked = false;
                document.getElementById('printToggleLabel').textContent = 'Print All';
            })
            .finally(() => {
                loadButton.disabled = false;
                loadButtonText.textContent = 'Upload';
                loadSpinner.classList.add('hidden');
            });
        });
        
        function populateDropdowns() {
            const nameColumn = document.getElementById('nameColumn');
            const columnSelect = document.getElementById('columnSelect');
            nameColumn.innerHTML = '';
            columnSelect.innerHTML = '';

            headers.forEach(header => {
                const option1 = document.createElement('option');
                option1.value = header;
                option1.textContent = header;
                nameColumn.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = header;
                option2.textContent = header;
                columnSelect.appendChild(option2);
                option2.selected = selectedColumns.includes(header);
            });

            nameColumn.addEventListener('change', function() {
                const selectedColumn = this.value;
                const isDateColumn = selectedColumn.toLowerCase().includes('date');
                
                const textSearchContainer = document.getElementById('textSearchContainer');
                const dateRangeContainer = document.getElementById('dateRangeContainer');
                const dateRangeActive = document.getElementById('dateRangeActive');
                
                if (isDateColumn) {
                    textSearchContainer.style.display = 'none';
                    dateRangeContainer.classList.add('active');
                    dateRangeActive.classList.add('hidden');
                    
                    document.getElementById('dateFrom').value = '';
                    document.getElementById('dateTo').value = '';
                } else {
                    textSearchContainer.style.display = 'block';
                    dateRangeContainer.classList.remove('active');
                    dateRangeActive.classList.add('hidden');
                    
                    updateSearchDropdown(selectedColumn);
                    
                    const input = document.getElementById('nameSearchInput');
                    input.value = '';
                    input.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        const dropdown = document.getElementById('nameSearchDropdown');
                        const options = dropdown.querySelectorAll('.combo-box-option');
                        
                        options.forEach(option => {
                            const text = option.textContent.toLowerCase();
                            if (text.includes(searchTerm) || searchTerm === '') {
                                option.style.display = 'block';
                            } else {
                                option.style.display = 'none';
                            }
                        });
                        
                        dropdown.classList.add('active');
                    });
                    
                    input.addEventListener('focus', () => {
                        const dropdown = document.getElementById('nameSearchDropdown');
                        dropdown.classList.add('active');
                    });
                    
                    document.addEventListener('click', (e) => {
                        if (!textSearchContainer.contains(e.target)) {
                            const dropdown = document.getElementById('nameSearchDropdown');
                            dropdown.classList.remove('active');
                        }
                    });
                }
            });
        }

        function updateSearchDropdown(column) {
            const uniqueValues = [...new Set(currentWorkingData.map(row => {
                const value = row[column];
                if (value === null || value === undefined) {
                    return '(Blank)';
                }
                if (value === 0 || value === '0') {
                    return '0'; // Explicitly handle 0 values
                }
                if (value.toString().trim() === '') {
                    return '(Blank)';
                }
                return value;
            }))].filter(val => val !== undefined);
            
            const dropdown = document.getElementById('nameSearchDropdown');
            dropdown.innerHTML = '';
            
            uniqueValues.forEach(value => {
                const option = document.createElement('div');
                option.className = value === '(Blank)' ? 'combo-box-option blank-option' : 'combo-box-option';
                option.textContent = value;
                option.dataset.value = value === '(Blank)' ? '' : value;
                option.addEventListener('click', () => {
                    document.getElementById('nameSearchInput').value = value === '(Blank)' ? '' : value;
                    dropdown.classList.remove('active');
                });
                dropdown.appendChild(option);
            });
        }

        function calculateBalanceAdjustment(row) {
            const type = (row['Type'] || row['Txn Type'] || 'Sale').toLowerCase();
            let adjustment = 0;

            if (type.includes('sale')) {
                adjustment = parseFloat(row['Balance'] || 0);
            } else if (type.includes('payment-out') || type.includes('party to party [paid]')) {
                adjustment = parseFloat(row['Paid'] || 0);
            } else if (type.includes('payment-in') || type.includes('party to party [received]')) {
                adjustment = -1 * parseFloat(row['Received'] || 0);
            } else if (type.includes('purchase') || type.includes('credit note')) {
                adjustment = -1 * parseFloat(row['Balance'] || 0);
            }

            return adjustment;
        }

        function calculateRunningBalances(data) {
            const transactions = {};
            let runningBalance = 0;

            const openingBalanceRow = data.find(row => row['Ref_No'] === 'Opening Balance');
            if (openingBalanceRow) {
                runningBalance = parseFloat(openingBalanceRow['Balance'] || 0);
            }

            data.forEach(row => {
                if (row['Ref_No'] === 'Opening Balance') return;
                
                const key = `${row['date']}_${row['Ref_No']}`;
                
                if (!transactions[key]) {
                    transactions[key] = {
                        adjustment: calculateBalanceAdjustment(row),
                        rows: []
                    };
                }
                transactions[key].rows.push(row);
            });

            const sortedKeys = Object.keys(transactions).sort((a, b) => {
                const dateA = new Date(a.split('_')[0].split('/').reverse().join('/'));
                const dateB = new Date(b.split('_')[0].split('/').reverse().join('/'));
                return dateA - dateB;
            });

            sortedKeys.forEach(key => {
                const group = transactions[key];
                runningBalance += group.adjustment;
                
                group.rows.forEach(row => {
                    row['Est. Balance'] = runningBalance;
                });
            });

            return data;
        }

        function sortData(column) {
            if (currentSortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                sortDirection = 'asc';
            }

            filteredData.sort((a, b) => {
                const valA = a[column];
                const valB = b[column];
                
                if (!isNaN(valA) && !isNaN(valB)) {
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
                
                const dateA = new Date(valA);
                const dateB = new Date(valB);
                if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                    return sortDirection === 'asc' ? dateA - dateB : dateB - dateA;
                }
                
                const strA = String(valA || '').toLowerCase();
                const strB = String(valB || '').toLowerCase();
                return sortDirection === 'asc' 
                    ? strA.localeCompare(strB) 
                    : strB.localeCompare(strA);
            });

            updateMatchingRowsTable();
        }

        function toggleRowSelection(index, checkbox) {
            const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
            if (checkbox.checked) {
                selectedRows.add(index);
                row.classList.add('selected-row');
            } else {
                selectedRows.delete(index);
                row.classList.remove('selected-row');
            }
            
            // Update the select all checkbox state
            const selectAllCheckbox = document.querySelector('.select-all-checkbox');
            const allCheckboxes = document.querySelectorAll('#matchingRowsTable tbody input.row-checkbox');
            const checkedCount = document.querySelectorAll('#matchingRowsTable tbody input.row-checkbox:checked').length;
            
            selectAllCheckbox.checked = checkedCount === allCheckboxes.length;
            selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < allCheckboxes.length;
        }

        function selectAllRows(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('#matchingRowsTable tbody input.row-checkbox');
            
            if (selectAllCheckbox.checked) {
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    const index = parseInt(checkbox.dataset.index);
                    selectedRows.add(index);
                    const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
                    row.classList.add('selected-row');
                });
            } else {
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                    const index = parseInt(checkbox.dataset.index);
                    selectedRows.delete(index);
                    const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
                    row.classList.remove('selected-row');
                });
            }
        }

        function updateMatchingRowsTable() {
            const table = document.getElementById('matchingRowsTable');
            const showAllBtn = document.getElementById('showAllRows');
            table.innerHTML = '';
            
            if (filteredData.length === 0) {
                showAllBtn.classList.add('hidden');
                return;
            }

            // First calculate running balances properly
            const dataWithBalances = calculateRunningBalances(filteredData);
            const rowsToShow = showingAllRows ? dataWithBalances : dataWithBalances.slice(0, 5);

            // Create a mapping between filtered row indices and original data indices
            rowIndexMap = [];
            filteredData.forEach((row, filteredIndex) => {
                const originalIndex = originalData.findIndex(originalRow => 
                    originalRow['Ref_No'] === row['Ref_No'] && 
                    originalRow['date'] === row['date']
                );
                if (originalIndex !== -1) {
                    rowIndexMap[filteredIndex] = originalIndex;
                }
            });

            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            
            // Add select all checkbox column
            const thSelect = document.createElement('th');
            const selectAllCheckbox = document.createElement('input');
            selectAllCheckbox.type = 'checkbox';
            selectAllCheckbox.className = 'row-checkbox select-all-checkbox';
            selectAllCheckbox.addEventListener('change', () => selectAllRows(selectAllCheckbox));
            thSelect.appendChild(selectAllCheckbox);
            tr.appendChild(thSelect);
            
            // Add sequential number column
            const thNum = document.createElement('th');
            thNum.textContent = '#';
            thNum.className = 'sortable-header';
            tr.appendChild(thNum);
            
            const displayColumns = selectedColumns.length > 0 ? selectedColumns : headers;
            
            displayColumns.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header === 'date' ? 'Date' : header;
                th.className = 'sortable-header';
                
                if (header === currentSortColumn) {
                    th.classList.add(sortDirection);
                }
                
                th.addEventListener('click', () => {
                    sortData(header);
                });
                
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            
            // Group transactions by Ref_No and date to calculate totals correctly
            const groupedTransactions = {};
            dataWithBalances.forEach(row => {
                const key = `${row['date']}_${row['Ref_No']}`;
                if (!groupedTransactions[key]) {
                    groupedTransactions[key] = {
                        rows: [],
                        total: 0,
                        received: parseFloat(row['Received'] || 0),
                        paid: parseFloat(row['Paid'] || 0),
                        balance: parseFloat(row['Balance'] || 0),
                        estBalance: parseFloat(row['Est. Balance'] || 0)
                    };
                }
                groupedTransactions[key].rows.push(row);
                groupedTransactions[key].total += parseFloat(row['Amount'] || 0);
            });

            // Calculate the final running balance
            let finalBalance = 0;
            Object.values(groupedTransactions).forEach(group => {
                finalBalance = group.estBalance;
            });

            // Now display the rows
            let rowIndex = 0;
            Object.keys(groupedTransactions).forEach(key => {
                const group = groupedTransactions[key];
                group.rows.forEach((row, itemIndex) => {
                    const tr = document.createElement('tr');
                    tr.dataset.index = rowIndex;
                    
                    // Add checkbox for row selection
                    const tdSelect = document.createElement('td');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'row-checkbox';
                    checkbox.dataset.index = rowIndex;
                    checkbox.addEventListener('change', (e) => toggleRowSelection(rowIndex, e.target));
                    if (selectedRows.has(rowIndex)) {
                        checkbox.checked = true;
                        tr.classList.add('selected-row');
                    }
                    tdSelect.appendChild(checkbox);
                    tr.appendChild(tdSelect);
                    
                    // Add sequential number
                    const tdNum = document.createElement('td');
                    tdNum.textContent = rowIndex + 1;
                    tr.appendChild(tdNum);
                    
                    displayColumns.forEach(header => {
                        const td = document.createElement('td');
                        if (header === 'Amount' || header === 'Received' || header === 'Total' || 
                            header === 'Paid' || header === 'Balance' || header === 'Est. Balance') {
                            td.className = 'amount-column';
                            // For grouped rows, only show the full values on the first row
                            if (itemIndex === 0 || !['Total', 'Received', 'Paid', 'Balance', 'Est. Balance'].includes(header)) {
                                td.textContent = row[header] ? parseFloat(row[header]).toFixed(2) : '0.00';
                            } else {
                                td.textContent = ''; // Leave empty for subsequent rows of same transaction
                            }
                        } else {
                            td.textContent = row[header] || '';
                        }
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                    rowIndex++;
                });
            });

            // Add summary rows
            const hasQuantity = displayColumns.includes('Quantity');
            const hasAmount = displayColumns.includes('Amount');
            const hasReceived = displayColumns.includes('Received');
            const hasTotal = displayColumns.includes('Total');
            const hasPaid = displayColumns.includes('Paid');

            if (hasQuantity || hasAmount || hasReceived || hasTotal || hasPaid) {
                const totalRow = document.createElement('tr');
                totalRow.className = 'total-row';
                
                const tdSelect = document.createElement('td');
                totalRow.appendChild(tdSelect);
                
                const tdNum = document.createElement('td');
                tdNum.textContent = '';
                totalRow.appendChild(tdNum);
                
                displayColumns.forEach(header => {
                    const td = document.createElement('td');
                    
                    if (header === 'Quantity') {
                        // Calculate total quantity
                        let totalQty = 0;
                        dataWithBalances.forEach(row => {
                            totalQty += parseFloat(row['Quantity'] || 0);
                        });
                        td.textContent = totalQty.toFixed(2);
                    } else if (header === 'Amount') {
                        // Calculate total amount
                        let totalAmt = 0;
                        dataWithBalances.forEach(row => {
                            totalAmt += parseFloat(row['Amount'] || 0);
                        });
                        td.className = 'amount-column';
                        td.textContent = totalAmt.toFixed(2);
                    } else {
                        td.textContent = '';
                    }
                    
                    totalRow.appendChild(td);
                });
                
                tbody.appendChild(totalRow);
            }

            // Description row
            const descRow = document.createElement('tr');
            descRow.className = 'description-row';
            const descCell = document.createElement('td');
            descCell.colSpan = displayColumns.length + 2;
            let customDescriptionText = '';
            const firstWithDescription = filteredData.find(row => row['Description_x']);
            if (firstWithDescription) {
                customDescriptionText = firstWithDescription['Description_x'];
            }
            descCell.textContent = `Description: ${customDescriptionText}`;
            descRow.appendChild(descCell);
            tbody.appendChild(descRow);

            // Sub Total and Total rows (now showing the final running balance)
            if ((hasAmount || hasTotal) && (hasReceived || hasPaid)) {
                const subtotalRow = document.createElement('tr');
                subtotalRow.className = 'subtotal-row';
                const subtotalCell = document.createElement('td');
                subtotalCell.colSpan = displayColumns.length + 1;
                subtotalCell.textContent = 'Sub Total:';
                subtotalRow.appendChild(subtotalCell);
                
                const subtotalValueCell = document.createElement('td');
                subtotalValueCell.className = 'amount-column';
                subtotalValueCell.textContent = finalBalance.toFixed(2);
                subtotalRow.appendChild(subtotalValueCell);
                tbody.appendChild(subtotalRow);

                const finalTotalRow = document.createElement('tr');
                finalTotalRow.className = 'final-total-row';
                const finalTotalCell = document.createElement('td');
                finalTotalCell.colSpan = displayColumns.length + 1;
                finalTotalCell.textContent = 'Total:';
                finalTotalRow.appendChild(finalTotalCell);
                
                const finalTotalValueCell = document.createElement('td');
                finalTotalValueCell.className = 'amount-column';
                finalTotalValueCell.textContent = finalBalance.toFixed(2);
                finalTotalRow.appendChild(finalTotalValueCell);
                tbody.appendChild(finalTotalRow);
            }
            
            table.appendChild(tbody);

            if (filteredData.length > 5 && !showingAllRows) {
                showAllBtn.classList.remove('hidden');
                showAllBtn.textContent = `Show All (${filteredData.length} rows)`;
            } else {
                showAllBtn.classList.add('hidden');
            }
        }

        function updateFilterHistory() {
            const filterHistoryContainer = document.getElementById('filterHistory');
            const filterHistoryItems = document.getElementById('filterHistoryItems');
            
            if (activeFilters.length === 0) {
                filterHistoryContainer.classList.add('hidden');
                return;
            }
            
            filterHistoryContainer.classList.remove('hidden');
            filterHistoryItems.innerHTML = '';
            
            activeFilters.forEach((filter, index) => {
                const filterItem = document.createElement('div');
                filterItem.className = 'filter-history-item';
                
                let filterText = '';
                if (filter.type === 'text') {
                    filterText = `${filter.column}: ${filter.value === '' ? '(Blank)' : filter.value}`;
                } else if (filter.type === 'date') {
                    filterText = `${filter.column}: ${filter.from || 'Start'} to ${filter.to || 'End'}`;
                }
                
                filterItem.innerHTML = `
                    <span>${filterText}</span>
                    <span class="filter-history-clear" data-index="${index}">×</span>
                `;
                
                filterHistoryItems.appendChild(filterItem);
            });
            
            // Add event listeners to remove buttons
            document.querySelectorAll('.filter-history-clear[data-index]').forEach(button => {
                button.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    removeFilter(index);
                });
            });
        }

        function removeFilter(index) {
            if (index >= 0 && index < activeFilters.length) {
                activeFilters.splice(index, 1);
                applyAllFilters();
            }
        }

        function applyAllFilters() {
            let workingData = [...originalData];
            
            activeFilters.forEach(filter => {
                if (filter.type === 'text') {
                    workingData = workingData.filter(row => {
                        const cellValue = row[filter.column];
                        
                        // Handle the case when filtering for blank values
                        if (filter.value === '') {
                            return cellValue === null || 
                                   cellValue === undefined || 
                                   (typeof cellValue === 'string' && cellValue.trim() === '');
                        }
                        // Handle the case when filtering for 0 (should include blank/null too)
                        else if (filter.value === '0') {
                            return cellValue === 0 || 
                                   cellValue === '0' || 
                                   cellValue === null || 
                                   cellValue === undefined || 
                                   (typeof cellValue === 'string' && cellValue.trim() === '');
                        }
                        // Handle other cases
                        else {
                            // For numeric comparison
                            if (!isNaN(cellValue) && !isNaN(filter.value)) {
                                return parseFloat(cellValue) === parseFloat(filter.value);
                            }
                            // For string comparison
                            return cellValue != null && cellValue.toString() === filter.value;
                        }
                    });
                } else if (filter.type === 'date') {
                    workingData = workingData.filter(row => {
                        const cellValue = row[filter.column];
                        if (!cellValue) return false;
                        
                        let cellDate;
                        if (cellValue instanceof Date) {
                            cellDate = new Date(cellValue);
                        } else if (typeof cellValue === 'string' || typeof cellValue === 'number') {
                            if (typeof cellValue === 'string' && cellValue.includes('/')) {
                                const parts = cellValue.split('/');
                                if (parts.length === 3) {
                                    const day = parseInt(parts[0], 10);
                                    const month = parseInt(parts[1], 10) - 1;
                                    const year = parseInt(parts[2], 10);
                                    cellDate = new Date(year, month, day);
                                } else {
                                    cellDate = new Date(cellValue);
                                }
                            } else {
                                cellDate = new Date(cellValue);
                            }
                        } else {
                            return false;
                        }
                        
                        if (isNaN(cellDate.getTime())) return false;
                        
                        const fromDate = filter.from ? new Date(filter.from) : null;
                        const toDate = filter.to ? new Date(filter.to) : null;
                        
                        if (fromDate) fromDate.setHours(0, 0, 0, 0);
                        if (toDate) toDate.setHours(23, 59, 59, 999);
                        cellDate.setHours(0, 0, 0, 0);
                        
                        if (fromDate && toDate) {
                            return cellDate >= fromDate && cellDate <= toDate;
                        } else if (fromDate) {
                            return cellDate >= fromDate;
                        } else if (toDate) {
                            return cellDate <= toDate;
                        }
                        return false;
                    });
                }
            });
            
            currentWorkingData = workingData;
            filteredData = [...workingData];
            
            // Remove blank/empty columns and columns with all zeros from filtered data
            const nonEmptyColumns = new Set();
            
            // First, find all columns that have at least one non-empty/non-zero value
            headers.forEach(header => {
                const hasData = filteredData.some(row => {
                    const value = row[header];
                    return value !== null && 
                           value !== undefined && 
                           value.toString().trim() !== '' && 
                           value !== 0 && 
                           value !== '0';
                });
                
                if (hasData) {
                    nonEmptyColumns.add(header);
                }
            });

            // Update selected columns to only include non-empty and non-zero ones
            selectedColumns = headers.filter(header => nonEmptyColumns.has(header));
            
            // Update the column select dropdown to reflect the new selection
            const columnSelect = document.getElementById('columnSelect');
            Array.from(columnSelect.options).forEach(option => {
                option.selected = selectedColumns.includes(option.value);
            });
            
            // Update the search dropdown with current working data
            const selectedColumn = document.getElementById('nameColumn').value;
            if (selectedColumn && !selectedColumn.toLowerCase().includes('date')) {
                updateSearchDropdown(selectedColumn);
            }
            
            // Update the table with filtered data
            currentSortColumn = null;
            sortDirection = 'asc';
            showingAllRows = false;
            selectedRows = new Set();
            document.getElementById('printToggle').checked = false;
            document.getElementById('printToggleLabel').textContent = 'Print All';
            updateMatchingRowsTable();
            updateFilterHistory();
        }

        document.getElementById('searchByName').addEventListener('click', () => {
            const column = document.getElementById('nameColumn').value;
            const isDateColumn = column.toLowerCase().includes('date');
            
            if (isDateColumn) {
                const dateFrom = document.getElementById('dateFrom').value;
                const dateTo = document.getElementById('dateTo').value;
                
                if (!dateFrom && !dateTo) {
                    alert('Please select at least one date for the range');
                    return;
                }
                
                // Add or update date filter
                const existingDateFilterIndex = activeFilters.findIndex(f => f.type === 'date' && f.column === column);
                
                if (existingDateFilterIndex >= 0) {
                    activeFilters[existingDateFilterIndex] = {
                        type: 'date',
                        column: column,
                        from: dateFrom,
                        to: dateTo
                    };
                } else {
                    activeFilters.push({
                        type: 'date',
                        column: column,
                        from: dateFrom,
                        to: dateTo
                    });
                }
                
                document.getElementById('dateRangeActive').textContent = `Active range: ${dateFrom || 'Start'} to ${dateTo || 'End'}`;
                document.getElementById('dateRangeActive').classList.remove('hidden');
            } else {
                let searchTerm = document.getElementById('nameSearchInput').value;
                
                // Explicitly handle the case when "0" is selected
                if (searchTerm === '0') {
                    searchTerm = '0'; // Keep as string to distinguish from blank
                }
                
                // Add or update text filter
                const existingTextFilterIndex = activeFilters.findIndex(f => f.type === 'text' && f.column === column);
                
                if (existingTextFilterIndex >= 0) {
                    activeFilters[existingTextFilterIndex] = {
                        type: 'text',
                        column: column,
                        value: searchTerm
                    };
                } else {
                    activeFilters.push({
                        type: 'text',
                        column: column,
                        value: searchTerm
                    });
                }
                
                document.getElementById('dateRangeActive').classList.add('hidden');
            }
            
            applyAllFilters();
        });

        document.getElementById('clearFilters').addEventListener('click', () => {
            activeFilters = [];
            currentWorkingData = [...originalData];
            filteredData = [...originalData];
            
            // Reset UI elements
            document.getElementById('nameSearchInput').value = '';
            document.getElementById('dateFrom').value = '';
            document.getElementById('dateTo').value = '';
            document.getElementById('dateRangeActive').classList.add('hidden');
            
            // Update the search dropdown with original data
            const selectedColumn = document.getElementById('nameColumn').value;
            if (selectedColumn && !selectedColumn.toLowerCase().includes('date')) {
                updateSearchDropdown(selectedColumn);
            }
            
            // Update the table with all data
            currentSortColumn = null;
            sortDirection = 'asc';
            showingAllRows = false;
            selectedRows = new Set();
            document.getElementById('printToggle').checked = false;
            document.getElementById('printToggleLabel').textContent = 'Print All';
            updateMatchingRowsTable();
            updateFilterHistory();
        });

        document.getElementById('showAllRows').addEventListener('click', () => {
            showingAllRows = true;
            updateMatchingRowsTable();
        });

        document.getElementById('applyFilters').addEventListener('click', () => {
            selectedColumns = Array.from(document.getElementById('columnSelect').selectedOptions).map(opt => opt.value);
            
            if (selectedColumns.length === 0) {
                selectedColumns = [...headers];
            }
            
            showingAllRows = false;
            updateMatchingRowsTable();
        });

        document.getElementById('printToggle').addEventListener('change', function() {
            document.getElementById('printToggleLabel').textContent = this.checked ? 'Print Selected' : 'Print All';
        });

        document.getElementById('executePrint').addEventListener('click', () => {
            const printToggle = document.getElementById('printToggle');
            
            if (printToggle.checked) {
                if (selectedRows.size === 0) {
                    alert('No rows selected. Please select rows to print.');
                    return;
                }
                
                // Get selected data with proper index mapping
                const selectedData = [];
                const checkboxes = document.querySelectorAll('#matchingRowsTable tbody input.row-checkbox:checked');
                
                checkboxes.forEach(checkbox => {
                    const index = parseInt(checkbox.dataset.index);
                    if (index >= 0 && index < filteredData.length) {
                        selectedData.push(filteredData[index]);
                    }
                });
                
                if (selectedData.length === 0) {
                    alert('No valid rows found for printing. Please try again.');
                    return;
                }
                
                prepareAndOpenPrintView(selectedData);
            } else {
                if (filteredData.length === 0) {
                    alert('No filtered data available. Please apply filters first.');
                    return;
                }
                prepareAndOpenPrintView(filteredData);
            }
        });

        function prepareAndOpenPrintView(dataToPrint) {
            // Ensure we have valid data
            if (!dataToPrint || dataToPrint.length === 0) {
                alert('No valid data to print');
                return;
            }

            const displayColumns = selectedColumns.length > 0 ? selectedColumns : headers;
            
            // Extract party information
            let partyInfo = { name: 'N/A', mobile: 'N/A' };
            const partyRow = dataToPrint.find(row => row['Party Name_y']);
            if (partyRow) {
                const partyString = partyRow['Party Name_y'];
                const mobileMatch = partyString.match(/\d{10}/);
                partyInfo.mobile = mobileMatch ? mobileMatch[0] : 'N/A';
                partyInfo.name = partyString.replace(/\(.*\d{10}.*\)/, '').trim();
                if (!partyInfo.name) {
                    partyInfo.name = partyString.replace(/\d{10}/, '').replace(/[()]/g, '').trim() || 'N/A';
                }
            }

            // Calculate date range
            const dateRange = { from: 'N/A', to: 'N/A' };
            const validDates = dataToPrint
                .map(row => row.date ? new Date(row.date.split('/').reverse().join('/')) : null)
                .filter(date => date && !isNaN(date.getTime()));
            
            if (validDates.length > 0) {
                const minDate = new Date(Math.min(...validDates));
                const maxDate = new Date(Math.max(...validDates));
                
                dateRange.from = `${String(minDate.getDate()).padStart(2, '0')}/${String(minDate.getMonth() + 1).padStart(2, '0')}/${minDate.getFullYear()}`;
                dateRange.to = `${String(maxDate.getDate()).padStart(2, '0')}/${String(maxDate.getMonth() + 1).padStart(2, '0')}/${maxDate.getFullYear()}`;
            }

            // Store data for print view
            sessionStorage.setItem('filteredData', JSON.stringify(dataToPrint));
            sessionStorage.setItem('columnsToShow', JSON.stringify(displayColumns));
            sessionStorage.setItem('dateRange', JSON.stringify(dateRange));
            sessionStorage.setItem('partyInfo', JSON.stringify(partyInfo));
            
            // Open print view in new tab
            const printWindow = window.open('/print', '_blank');
            if (!printWindow) {
                alert('Popup blocked. Please allow popups for this site.');
            }
        
            
            setTimeout(() => {
                const printWindow = window.open('/print', '_blank');
                if (!printWindow) {
                    alert('Popup blocked. Please allow popups for this site.');
                }
            }, 100);
        }
    </script>
</body>
</html>