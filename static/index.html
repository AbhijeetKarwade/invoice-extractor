<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G.Printer</title>
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .collapsible-content { display: none; }
        .collapsible-content.active { display: block; }
        .table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #ddd;
            border-radius: 0.375rem;
        }
        .table-container table { margin-top: 0; }
        .table-container thead th {
            position: sticky;
            top: 0;
            z-index: 10;
            background-color: #f2f2f2;
        }
        .show-more-btn {
            display: block;
            width: 100%;
            text-align: center;
            padding: 0.5rem;
            background-color: #3b82f6;
            color: white;
            border-radius: 0.375rem;
            margin-top: 0.5rem;
        }
        .show-more-btn:hover { background-color: #2563eb; }
        .date-range-container {
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .date-range-container.active { display: grid; }
        
        /* Sorting styles */
        .sortable-header {
            cursor: pointer;
            position: relative;
            padding-right: 20px !important;
        }
        .sortable-header::after {
            content: "";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            opacity: 0.3;
        }
        .sortable-header.asc::after {
            border-bottom: 5px solid #333;
            opacity: 1;
        }
        .sortable-header.desc::after {
            border-top: 5px solid #333;
            opacity: 1;
        }
        .sortable-header:hover::after {
            opacity: 0.7;
        }
        
        /* Combo box styles */
        .combo-box {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .combo-box input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 0.25rem;
        }
        .combo-box-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            z-index: 1000;
            display: none;
        }
        .combo-box-options.active {
            display: block;
        }
        .combo-box-option {
            padding: 0.5rem;
            cursor: pointer;
        }
        .combo-box-option:hover {
            background-color: #f0f0f0;
        }
        .combo-box-option.selected {
            background-color: #e0e0e0;
        }

        /* Section header styles */
        .section-header {
            background-color: #3b82f6;
            color: white;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            text-align: center;
        }

        /* Control panel styles */
        .control-panel-section {
            background-color: white;
            padding: 0.5rem;
            border-radius: 0.375rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Date range active indicator */
        .date-range-active {
            background-color: #f0f9ff;
            border: 1px solid #3b82f6;
            border-radius: 0.25rem;
            padding: 0.25rem;
            font-size: 0.75rem;
            margin-top: 0.25rem;
            display: none;
        }

        /* Summary row styles */
        .total-row td {
            font-weight: bold;
            background-color: #f0f0f0;
        }
        .subtotal-row td {
            font-weight: bold;
            background-color: #e0e0e0;
            text-align: right;
        }
        .final-total-row td {
            font-weight: bold;
            background-color: #d0d0d0;
            text-align: right;
        }
        .description-row td {
            font-style: italic;
            color: #666;
            font-family: "Calibri", "Calibri Body", sans-serif;
        }
        .amount-column {
            text-align: right;
        }
        
        /* Selected row style */
        .selected-row {
            background-color: #e6f7ff !important;
        }
        
        /* Checkbox styles */
        .row-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        /* Select all checkbox */
        .select-all-checkbox {
            margin-right: 5px;
        }

        /* Toggle switch styles */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3b82f6;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #10b981;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(32px);
        }

        .toggle-label {
            font-size: 0.875rem;
            color: #333;
        }

        /* Sheet info styles */
        .sheet-info {
            font-size: 0.75rem;
            margin-top: 0.5rem;
            padding: 0.25rem;
            background-color: #f8fafc;
            border-radius: 0.25rem;
        }
        .sheet-info-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        .sheet-info-row {
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body class="p-4 bg-gray-100">
    <h1 class="text-2xl font-bold mb-4">G Printer</h1>
    
    <!-- Top Control Panel -->
    <div class="bg-white p-4 rounded shadow mb-6">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <!-- File Input -->
            <div>
                <div class="section-header">Load File</div>
                <div class="control-panel-section">
                    <input type="file" id="fileInput" accept=".xlsx" class="text-sm w-full mb-2">
                    <button id="loadFile" class="bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600 w-full text-sm flex items-center justify-center gap-2">
                        <span id="loadButtonText">Upload</span>
                        <span id="loadSpinner" class="spinner hidden"></span>
                    </button>
                    <div id="sheetInfo" class="sheet-info hidden">
                        <div class="sheet-info-title">Sheets in uploaded file:</div>
                        <div class="sheet-info-row">
                            <span>Custom Report:</span>
                            <span id="customReportRows">0 rows</span>
                        </div>
                        <div class="sheet-info-row">
                            <span>Item Details:</span>
                            <span id="itemDetailsRows">0 rows</span>
                        </div>
                        <div class="sheet-info-row">
                            <span>Merged unique Data:</span>
                            <span id="mergedDataRows">0 rows</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Search -->
            <div>
                <div class="section-header">Search</div>
                <div class="control-panel-section">
                    <select id="nameColumn" class="border p-1 rounded w-full text-sm mb-2"></select>
                    <div id="textSearchContainer">
                        <div class="combo-box">
                            <input type="text" id="nameSearchInput" placeholder="Type to search or select..." class="border p-1 rounded w-full text-sm">
                            <div id="nameSearchDropdown" class="combo-box-options"></div>
                        </div>
                    </div>
                    <div id="dateRangeContainer" class="date-range-container">
                        <div>
                            <label class="text-xs">From:</label>
                            <input type="date" id="dateFrom" class="border p-1 rounded w-full text-sm">
                        </div>
                        <div>
                            <label class="text-xs">To:</label>
                            <input type="date" id="dateTo" class="border p-1 rounded w-full text-sm">
                        </div>
                    </div>
                    <div id="dateRangeActive" class="date-range-active hidden"></div>
                    <button id="searchByName" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 mt-2 w-full text-sm">
                        Apply
                    </button>
                </div>
            </div>

            <!-- Column Selection -->
            <div>
                <div class="section-header">Select columns</div>
                <div class="control-panel-section">
                    <select id="columnSelect" multiple class="border p-2 rounded w-full text-sm h-16 mb-2"></select>
                    <button id="applyFilters" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 w-full text-sm">
                        Apply & Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Export Buttons -->
        <div class="flex flex-wrap gap-2 mt-4 items-center">
            <div class="toggle-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="printToggle">
                    <span class="toggle-slider"></span>
                </label>
                <span id="printToggleLabel" class="toggle-label">Print All</span>
            </div>
            <button id="executePrint" class="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600 text-sm">
                View & Print
            </button>
        </div>
    </div>

    <!-- Filtered Rows Table -->
    <h2 class="text-xl font-semibold mt-6">Filtered Rows</h2>
    <div class="table-container">
        <table id="matchingRowsTable" class="bg-white"></table>
    </div>
    <button id="showAllRows" class="show-more-btn hidden">Show All Rows</button>

    <script>
        let data = [];
        let headers = [];
        let filteredData = [];
        let showingAllRows = false;
        let originalData = [];
        let selectedColumns = [];
        let currentSortColumn = null;
        let sortDirection = 'asc';
        let selectedRows = new Set();

        // Load Excel File
        document.getElementById('loadFile').addEventListener('click', () => {
            const file = document.getElementById('fileInput').files[0];
            if (!file) {
                alert('Please select a file.');
                return;
            }

            // Show loading state
            const loadButtonText = document.getElementById('loadButtonText');
            const loadSpinner = document.getElementById('loadSpinner');
            const loadButton = document.getElementById('loadFile');
            
            loadButton.disabled = true;
            loadButtonText.textContent = 'Processing...';
            loadSpinner.classList.remove('hidden');

            // Create FormData object to send the file
            const formData = new FormData();
            formData.append('file', file);

            // Send the file to the server for processing
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || 'Network response was not ok');
                    });
                }
                return response.json();
            })
            .then(responseData => {
                if (responseData.error) {
                    throw new Error(responseData.error);
                }

                // Process the returned data directly
                data = responseData.data || [];
                headers = responseData.headers || (data.length > 0 ? Object.keys(data[0]) : []);
                
                if (data.length === 0) {
                    throw new Error('No data found in the processed file');
                }
                
                // Store the data
                originalData = [...data];
                filteredData = [...data];
                selectedColumns = [...headers];
                showingAllRows = false;
                currentSortColumn = null;
                sortDirection = 'asc';
                selectedRows = new Set();
                
                updateMatchingRowsTable();
                populateDropdowns();
                
                // Display sheet information
                const sheetInfoDiv = document.getElementById('sheetInfo');
                sheetInfoDiv.classList.remove('hidden');
                document.getElementById('customReportRows').textContent = 
                    `${responseData.sheetStats?.customReportRows || 'N/A'} rows`;
                document.getElementById('itemDetailsRows').textContent = 
                    `${responseData.sheetStats?.itemDetailsRows || 'N/A'} rows`;
                document.getElementById('mergedDataRows').textContent = 
                    `${data.length} rows`;
                
                document.getElementById('printToggle').checked = false;
                document.getElementById('printToggleLabel').textContent = 'Print All';
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred: ' + error.message);
                
                // Clear any existing data
                data = [];
                headers = [];
                originalData = [];
                filteredData = [];
                selectedRows = new Set();
                updateMatchingRowsTable();
                document.getElementById('sheetInfo').classList.add('hidden');
                document.getElementById('printToggle').checked = false;
                document.getElementById('printToggleLabel').textContent = 'Print All';
            })
            .finally(() => {
                // Reset button state
                loadButton.disabled = false;
                loadButtonText.textContent = 'Upload';
                loadSpinner.classList.add('hidden');
            });
        });
        
        // Populate Dropdowns
        function populateDropdowns() {
            const nameColumn = document.getElementById('nameColumn');
            const columnSelect = document.getElementById('columnSelect');
            nameColumn.innerHTML = '';
            columnSelect.innerHTML = '';

            headers.forEach(header => {
                const option1 = document.createElement('option');
                option1.value = header;
                option1.textContent = header;
                nameColumn.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = header;
                option2.textContent = header;
                columnSelect.appendChild(option2);
                option2.selected = selectedColumns.includes(header);
            });

            nameColumn.addEventListener('change', function() {
                const selectedColumn = this.value;
                const isDateColumn = selectedColumn.toLowerCase().includes('date');
                
                const textSearchContainer = document.getElementById('textSearchContainer');
                const dateRangeContainer = document.getElementById('dateRangeContainer');
                const dateRangeActive = document.getElementById('dateRangeActive');
                
                if (isDateColumn) {
                    textSearchContainer.style.display = 'none';
                    dateRangeContainer.classList.add('active');
                    dateRangeActive.classList.add('hidden');
                    
                    // Clear date inputs when switching to date column
                    document.getElementById('dateFrom').value = '';
                    document.getElementById('dateTo').value = '';
                } else {
                    textSearchContainer.style.display = 'block';
                    dateRangeContainer.classList.remove('active');
                    dateRangeActive.classList.add('hidden');
                    
                    // Get unique values for the selected column
                    const uniqueValues = [...new Set(originalData.map(row => row[selectedColumn]))].filter(Boolean);
                    
                    // Clear previous dropdown
                    const dropdown = document.getElementById('nameSearchDropdown');
                    dropdown.innerHTML = '';
                    
                    // Create new options
                    uniqueValues.forEach(value => {
                        const option = document.createElement('div');
                        option.className = 'combo-box-option';
                        option.textContent = value;
                        option.dataset.value = value;
                        option.addEventListener('click', () => {
                            document.getElementById('nameSearchInput').value = value;
                            dropdown.classList.remove('active');
                        });
                        dropdown.appendChild(option);
                    });
                    
                    // Setup input event for filtering
                    const input = document.getElementById('nameSearchInput');
                    input.value = '';
                    input.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        const options = dropdown.querySelectorAll('.combo-box-option');
                        
                        options.forEach(option => {
                            const text = option.textContent.toLowerCase();
                            if (text.includes(searchTerm)) {
                                option.style.display = 'block';
                            } else {
                                option.style.display = 'none';
                            }
                        });
                        
                        dropdown.classList.add('active');
                    });
                    
                    // Show dropdown when input is focused
                    input.addEventListener('focus', () => {
                        dropdown.classList.add('active');
                    });
                    
                    // Hide dropdown when clicking outside
                    document.addEventListener('click', (e) => {
                        if (!textSearchContainer.contains(e.target)) {
                            dropdown.classList.remove('active');
                        }
                    });
                }
            });
        }

        // Sort data function
        function sortData(column) {
            if (currentSortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                sortDirection = 'asc';
            }

            filteredData.sort((a, b) => {
                const valA = a[column];
                const valB = b[column];
                
                // Handle numbers
                if (!isNaN(valA) && !isNaN(valB)) {
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
                
                // Handle dates
                const dateA = new Date(valA);
                const dateB = new Date(valB);
                if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                    return sortDirection === 'asc' ? dateA - dateB : dateB - dateA;
                }
                
                // Default to string comparison
                const strA = String(valA || '').toLowerCase();
                const strB = String(valB || '').toLowerCase();
                return sortDirection === 'asc' 
                    ? strA.localeCompare(strB) 
                    : strB.localeCompare(strA);
            });

            updateMatchingRowsTable();
        }

        // Toggle row selection
        function toggleRowSelection(index, checkbox) {
            const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
            if (checkbox.checked) {
                selectedRows.add(index);
                row.classList.add('selected-row');
            } else {
                selectedRows.delete(index);
                row.classList.remove('selected-row');
            }
        }

        // Select all rows
        function selectAllRows(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('#matchingRowsTable tbody input.row-checkbox');
            
            if (selectAllCheckbox.checked) {
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    const index = parseInt(checkbox.dataset.index);
                    selectedRows.add(index);
                    const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
                    row.classList.add('selected-row');
                });
            } else {
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                    const index = parseInt(checkbox.dataset.index);
                    selectedRows.delete(index);
                    const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
                    row.classList.remove('selected-row');
                });
            }
        }

        // Update Matching Rows Table with sorting and summary rows
        function updateMatchingRowsTable() {
            const table = document.getElementById('matchingRowsTable');
            const showAllBtn = document.getElementById('showAllRows');
            table.innerHTML = '';
            
            if (filteredData.length === 0) {
                showAllBtn.classList.add('hidden');
                return;
            }

            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            
            // Add select all checkbox column
            const thSelect = document.createElement('th');
            const selectAllCheckbox = document.createElement('input');
            selectAllCheckbox.type = 'checkbox';
            selectAllCheckbox.className = 'row-checkbox select-all-checkbox';
            selectAllCheckbox.addEventListener('change', () => selectAllRows(selectAllCheckbox));
            thSelect.appendChild(selectAllCheckbox);
            tr.appendChild(thSelect);
            
            // Add sequential number column
            const thNum = document.createElement('th');
            thNum.textContent = '#';
            thNum.className = 'sortable-header';
            tr.appendChild(thNum);
            
            const displayColumns = selectedColumns.length > 0 ? selectedColumns : headers;
            
            displayColumns.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header === 'date' ? 'Date' : header;
                th.className = 'sortable-header';
                
                if (header === currentSortColumn) {
                    th.classList.add(sortDirection);
                }
                
                th.addEventListener('click', () => {
                    sortData(header);
                });
                
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            const rowsToShow = showingAllRows ? filteredData : filteredData.slice(0, 5);
            
            // Calculate totals for the visible rows
            let totalQuantity = 0;
            let totalAmount = 0;
            let totalReceived = 0;
            let totalTotal = 0;
            let totalPaid = 0;

            rowsToShow.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.dataset.index = index;
                
                // Add checkbox for row selection
                const tdSelect = document.createElement('td');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'row-checkbox';
                checkbox.dataset.index = index;
                checkbox.addEventListener('change', (e) => toggleRowSelection(index, e.target));
                if (selectedRows.has(index)) {
                    checkbox.checked = true;
                    tr.classList.add('selected-row');
                }
                tdSelect.appendChild(checkbox);
                tr.appendChild(tdSelect);
                
                // Add sequential number
                const tdNum = document.createElement('td');
                tdNum.textContent = index + 1;
                tr.appendChild(tdNum);
                
                displayColumns.forEach(header => {
                    const td = document.createElement('td');
                    if (header === 'Amount' || header === 'Received' || header === 'Total' || header === 'Paid') {
                        td.className = 'amount-column';
                        td.textContent = row[header] ? parseFloat(row[header]).toFixed(2) : '0.00';
                    } else {
                        td.textContent = row[header] || '';
                    }
                    tr.appendChild(td);
                    
                    // Sum quantities and amounts
                    if (header === 'Quantity') {
                        totalQuantity += parseFloat(row[header]) || 0;
                    }
                    if (header === 'Amount') {
                        totalAmount += parseFloat(row[header]) || 0;
                    }
                    if (header === 'Received') {
                        totalReceived += parseFloat(row[header]) || 0;
                    }
                    if (header === 'Total') {
                        totalTotal += parseFloat(row[header]) || 0;
                    }
                    if (header === 'Paid') {
                        totalPaid += parseFloat(row[header]) || 0;
                    }
                });
                tbody.appendChild(tr);
            });

            // Group transactions by Ref_No for running balance calculation
            const transactions = {};
            filteredData.forEach(row => {
                const refNo = row['Ref_No'] || 'Opening Balance';
                if (!transactions[refNo]) {
                    transactions[refNo] = {
                        date: row['date'],
                        type: row['Txn Type'] || 'Sale',
                        refNo: refNo,
                        total: 0,
                        received: 0,
                        paid: 0,
                        balance: 0
                    };
                }
                
                // Use 'Total' column if available, otherwise fall back to 'Amount'
                const totalValue = row['Total'] !== undefined ? parseFloat(row['Total'] || 0) : parseFloat(row['Amount'] || 0);
                transactions[refNo].total += totalValue;
                transactions[refNo].received += parseFloat(row['Received'] || 0);
                transactions[refNo].paid += parseFloat(row['Paid'] || 0);
                transactions[refNo].balance = transactions[refNo].total - (transactions[refNo].received + transactions[refNo].paid);
            });

            // Calculate opening balance and running balance
            let openingBalance = 0;
            if (transactions['Opening Balance']) {
                const openingTotal = transactions['Opening Balance'].total;
                const openingReceived = transactions['Opening Balance'].received;
                const openingPaid = transactions['Opening Balance'].paid;
                openingBalance = openingTotal - (openingReceived + openingPaid);
                delete transactions['Opening Balance'];
            }

            const sortedTransactions = Object.values(transactions).sort((a, b) => {
                const dateA = a.date ? new Date(a.date.split('/').reverse().join('/')) : new Date(0);
                const dateB = b.date ? new Date(b.date.split('/').reverse().join('/')) : new Date(0);
                return dateA - dateB;
            });

            let runningBalance = openingBalance;
            let grandTotal = runningBalance;
            
            sortedTransactions.forEach(txn => {
                runningBalance += txn.balance;
                grandTotal = runningBalance;
            });

            // Add summary rows if we have quantity, amount, or received columns
            const hasQuantity = displayColumns.includes('Quantity');
            const hasAmount = displayColumns.includes('Amount');
            const hasReceived = displayColumns.includes('Received');
            const hasTotal = displayColumns.includes('Total');
            const hasPaid = displayColumns.includes('Paid');

            if (hasQuantity || hasAmount || hasReceived || hasTotal || hasPaid) {
                // Total row for Quantity, Amount, Received
                const totalRow = document.createElement('tr');
                totalRow.className = 'total-row';
                
                // Add empty checkbox column
                const tdSelect = document.createElement('td');
                totalRow.appendChild(tdSelect);
                
                // Add # column
                const tdNum = document.createElement('td');
                tdNum.textContent = '';
                totalRow.appendChild(tdNum);
                
                // Add cells for each column
                displayColumns.forEach(header => {
                    const td = document.createElement('td');
                    
                    if (header === 'Quantity') {
                        td.textContent = totalQuantity.toFixed(2);
                    } else if (header === 'Amount') {
                        td.className = 'amount-column';
                        td.textContent = totalAmount.toFixed(2);
                    } else if (header === 'Received') {
                        td.className = 'amount-column';
                        td.textContent = totalReceived.toFixed(2);
                    } else if (header === 'Total') {
                        td.className = 'amount-column';
                        td.textContent = totalTotal.toFixed(2);
                    } else if (header === 'Paid') {
                        td.className = 'amount-column';
                        td.textContent = totalPaid.toFixed(2);
                    } else {
                        td.textContent = '';
                    }
                    
                    totalRow.appendChild(td);
                });
                
                tbody.appendChild(totalRow);
            }

            // Description row
            const descRow = document.createElement('tr');
            descRow.className = 'description-row';
            const descCell = document.createElement('td');
            descCell.colSpan = displayColumns.length + 2;
            let customDescriptionText = '';
            const firstWithDescription = filteredData.find(row => row['Description_x']);
            if (firstWithDescription) {
                customDescriptionText = firstWithDescription['Description_x'];
            }
            descCell.textContent = `Description: ${customDescriptionText}`;
            descRow.appendChild(descCell);
            tbody.appendChild(descRow);

            // Sub Total row (running balance)
            if ((hasAmount || hasTotal) && (hasReceived || hasPaid)) {
                const subtotalRow = document.createElement('tr');
                subtotalRow.className = 'subtotal-row';
                const subtotalCell = document.createElement('td');
                subtotalCell.colSpan = displayColumns.length + 1;
                subtotalCell.textContent = 'Sub Total:';
                subtotalRow.appendChild(subtotalCell);
                
                const subtotalValueCell = document.createElement('td');
                subtotalValueCell.className = 'amount-column';
                subtotalValueCell.textContent = grandTotal.toFixed(2);
                subtotalRow.appendChild(subtotalValueCell);
                tbody.appendChild(subtotalRow);
            }

            // Final Total row (same as Sub Total in this case)
            if ((hasAmount || hasTotal) && (hasReceived || hasPaid)) {
                const finalTotalRow = document.createElement('tr');
                finalTotalRow.className = 'final-total-row';
                const finalTotalCell = document.createElement('td');
                finalTotalCell.colSpan = displayColumns.length + 1;
                finalTotalCell.textContent = 'Total:';
                finalTotalRow.appendChild(finalTotalCell);
                
                const finalTotalValueCell = document.createElement('td');
                finalTotalValueCell.className = 'amount-column';
                finalTotalValueCell.textContent = grandTotal.toFixed(2);
                finalTotalRow.appendChild(finalTotalValueCell);
                tbody.appendChild(finalTotalRow);
            }
            
            table.appendChild(tbody);

            if (filteredData.length > 5 && !showingAllRows) {
                showAllBtn.classList.remove('hidden');
                showAllBtn.textContent = `Show All (${filteredData.length} rows)`;
            } else {
                showAllBtn.classList.add('hidden');
            }
        }

        // Search by Name or Date with proper DD/MM/YYYY handling
        document.getElementById('searchByName').addEventListener('click', () => {
            const column = document.getElementById('nameColumn').value;
            const isDateColumn = column.toLowerCase().includes('date');
            
            if (isDateColumn) {
                const dateFrom = document.getElementById('dateFrom').value;
                const dateTo = document.getElementById('dateTo').value;
                
                if (!dateFrom && !dateTo) {
                    alert('Please select at least one date for the range');
                    return;
                }
                
                // Show active date range
                const dateRangeActive = document.getElementById('dateRangeActive');
                dateRangeActive.textContent = `Active range: ${dateFrom || 'Start'} to ${dateTo || 'End'}`;
                dateRangeActive.classList.remove('hidden');
                
                filteredData = originalData.filter(row => {
                    const cellValue = row[column];
                    if (!cellValue) return false;
                    
                    // Parse the cell value as a date in DD/MM/YYYY format
                    let cellDate;
                    if (cellValue instanceof Date) {
                        cellDate = new Date(cellValue);
                    } else if (typeof cellValue === 'string' || typeof cellValue === 'number') {
                        // Handle string dates in DD/MM/YYYY format
                        if (typeof cellValue === 'string' && cellValue.includes('/')) {
                            const parts = cellValue.split('/');
                            if (parts.length === 3) {
                                // Force DD/MM/YYYY interpretation
                                const day = parseInt(parts[0], 10);
                                const month = parseInt(parts[1], 10) - 1; // months are 0-indexed
                                const year = parseInt(parts[2], 10);
                                cellDate = new Date(year, month, day);
                            } else {
                                cellDate = new Date(cellValue);
                            }
                        } else {
                            cellDate = new Date(cellValue);
                        }
                    } else {
                        return false;
                    }
                    
                    if (isNaN(cellDate.getTime())) return false;
                    
                    // Convert the filter dates from YYYY-MM-DD to Date objects
                    const fromDate = dateFrom ? new Date(dateFrom) : null;
                    const toDate = dateTo ? new Date(dateTo) : null;
                    
                    // Reset time components for accurate date comparison
                    if (fromDate) fromDate.setHours(0, 0, 0, 0);
                    if (toDate) toDate.setHours(23, 59, 59, 999);
                    cellDate.setHours(0, 0, 0, 0);
                    
                    // Compare dates
                    if (fromDate && toDate) {
                        return cellDate >= fromDate && cellDate <= toDate;
                    } else if (fromDate) {
                        return cellDate >= fromDate;
                    } else if (toDate) {
                        return cellDate <= toDate;
                    }
                    return false;
                });
            } else {
                const searchTerm = document.getElementById('nameSearchInput').value;
                filteredData = originalData.filter(row =>
                    row[column] && row[column].toString() === searchTerm
                );

                // Remove blank/empty columns and columns with all zeros from filtered data
                const nonEmptyColumns = new Set();
                
                // First, find all columns that have at least one non-empty/non-zero value
                headers.forEach(header => {
                    const hasData = filteredData.some(row => {
                        const value = row[header];
                        return value !== null && 
                               value !== undefined && 
                               value.toString().trim() !== '' && 
                               value !== 0 && 
                               value !== '0';
                    });
                    
                    if (hasData) {
                        nonEmptyColumns.add(header);
                    }
                });

                // Update selected columns to only include non-empty and non-zero ones
                selectedColumns = headers.filter(header => nonEmptyColumns.has(header));
                
                // Update the column select dropdown to reflect the new selection
                const columnSelect = document.getElementById('columnSelect');
                Array.from(columnSelect.options).forEach(option => {
                    option.selected = selectedColumns.includes(option.value);
                });
                
                document.getElementById('dateRangeActive').classList.add('hidden');
            }

            currentSortColumn = null;
            sortDirection = 'asc';
            showingAllRows = false;
            selectedRows = new Set();
            document.getElementById('printToggle').checked = false;
            document.getElementById('printToggleLabel').textContent = 'Print All';
            updateMatchingRowsTable();
        });

        // Toggle showing all rows
        document.getElementById('showAllRows').addEventListener('click', () => {
            showingAllRows = true;
            updateMatchingRowsTable();
        });

        // Apply Column Filters
        document.getElementById('applyFilters').addEventListener('click', () => {
            selectedColumns = Array.from(document.getElementById('columnSelect').selectedOptions).map(opt => opt.value);
            
            if (selectedColumns.length === 0) {
                selectedColumns = [...headers];
            }
            
            showingAllRows = false;
            updateMatchingRowsTable();
        });

        
        // Print Toggle Switch
        document.getElementById('printToggle').addEventListener('change', function() {
            document.getElementById('printToggleLabel').textContent = this.checked ? 'Print Selected' : 'Print All';
        });

        // Execute Print
        document.getElementById('executePrint').addEventListener('click', () => {
            const printToggle = document.getElementById('printToggle');
            
            if (printToggle.checked) {
                // Print Selected
                if (selectedRows.size === 0) {
                    alert('No rows selected. Please select rows to print.');
                    return;
                }
                const selectedData = Array.from(selectedRows).map(index => filteredData[index]);
                prepareAndOpenPrintView(selectedData);
            } else {
                // Print All
                if (filteredData.length === 0) {
                    alert('No filtered data available. Please apply filters first.');
                    return;
                }
                prepareAndOpenPrintView(filteredData);
            }
        });

        // Prepare data and open print view
        function prepareAndOpenPrintView(dataToPrint) {
            const displayColumns = selectedColumns.length > 0 ? selectedColumns : headers;
            
            // Find the first row with Party Name
            const partyRow = dataToPrint.find(row => row['Party Name_y']);
            let partyInfo = { name: '', mobile: '' };
            
            if (partyRow) {
                const partyString = partyRow['Party Name_y'];
                // Extract name and mobile
                const mobileMatch = partyString.match(/\d{10}/);
                partyInfo.mobile = mobileMatch ? mobileMatch[0] : '';
                
                // Extract name by removing the mobile part and parentheses
                partyInfo.name = partyString.replace(/\(.*\d{10}.*\)/, '').trim();
                if (!partyInfo.name) {
                    // If name is empty after removal, use the full string without mobile
                    partyInfo.name = partyString.replace(/\d{10}/, '').replace(/[()]/g, '').trim();
                }
            }
            
            // Get date range from the date filter inputs
            const dateRange = { from: '', to: '' };
            const dateFromInput = document.getElementById('dateFrom');
            const dateToInput = document.getElementById('dateTo');
            
            if (dateFromInput.value || dateToInput.value) {
                if (dateFromInput.value) {
                    const [y, m, d] = dateFromInput.value.split('-');
                    dateRange.from = `${d}/${m}/${y}`;
                }
                if (dateToInput.value) {
                    const [y, m, d] = dateToInput.value.split('-');
                    dateRange.to = `${d}/${m}/${y}`;
                }
            } else {
                // If no date filter is applied, show the min and max dates from the data
                const dates = dataToPrint.map(row => {
                    if (row.date) {
                        const [d, m, y] = row.date.split('/');
                        return new Date(`${y}-${m}-${d}`);
                    }
                    return null;
                }).filter(date => date);
                
                if (dates.length > 0) {
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    
                    dateRange.from = `${String(minDate.getDate()).padStart(2, '0')}/${String(minDate.getMonth() + 1).padStart(2, '0')}/${minDate.getFullYear()}`;
                    dateRange.to = `${String(maxDate.getDate()).padStart(2, '0')}/${String(maxDate.getMonth() + 1).padStart(2, '0')}/${maxDate.getFullYear()}`;
                }
            }
            
            // Store additional data needed for the new print format
            sessionStorage.setItem('filteredData', JSON.stringify(dataToPrint));
            sessionStorage.setItem('columnsToShow', JSON.stringify(displayColumns));
            sessionStorage.setItem('dateRange', JSON.stringify(dateRange));
            sessionStorage.setItem('partyInfo', JSON.stringify(partyInfo));
            
            setTimeout(() => {
                const printWindow = window.open('/print', '_blank');
                if (!printWindow) {
                    alert('Popup blocked. Please allow popups for this site.');
                }
            }, 100);
        }
    </script>
</body>
</html>