<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G.Printer</title>
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .collapsible-content { display: none; }
        .collapsible-content.active { display: block; }
        .table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #ddd;
            border-radius: 0.375rem;
        }
        .table-container table { margin-top: 0; }
        .table-container thead th {
            position: sticky;
            top: 0;
            z-index: 10;
            background-color: #f2f2f2;
        }
        .show-more-btn {
            display: block;
            width: 100%;
            text-align: center;
            padding: 0.5rem;
            background-color: #3b82f6;
            color: white;
            border-radius: 0.375rem;
            margin-top: 0.5rem;
        }
        .show-more-btn:hover { background-color: #2563eb; }
        .date-range-container {
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .date-range-container.active { display: grid; }
        
        .sortable-header {
            cursor: pointer;
            position: relative;
            padding-right: 20px !important;
        }
        .sortable-header::after {
            content: "";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            opacity: 0.3;
        }
        .sortable-header.asc::after {
            border-bottom: 5px solid #333;
            opacity: 1;
        }
        .sortable-header.desc::after {
            border-top: 5px solid #333;
            opacity: 1;
        }
        .sortable-header:hover::after { opacity: 0.7; }
        
        .combo-box {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .combo-box input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 0.25rem;
        }
        .combo-box-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            z-index: 1000;
            display: none;
        }
        .combo-box-options.active { display: block; }
        .combo-box-option {
            padding: 0.5rem;
            cursor: pointer;
        }
        .combo-box-option:hover { background-color: #f0f0f0; }
        .combo-box-option.selected { background-color: #e0e0e0; }
        .combo-box-option.blank-option { font-style: italic; color: #666; }

        .section-header {
            background-color: #3b82f6;
            color: white;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            text-align: center;
        }

        .control-panel-section {
            background-color: white;
            padding: 0.5rem;
            border-radius: 0.375rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .date-range-active {
            background-color: #f0f9ff;
            border: 1px solid #3b82f6;
            border-radius: 0.25rem;
            padding: 0.25rem;
            font-size: 0.75rem;
            margin-top: 0.25rem;
            display: none;
        }

        .total-row td { font-weight: bold; background-color: #f0f0f0; }
        .subtotal-row td { font-weight: bold; background-color: #e0e0e0; text-align: right; }
        .final-total-row td { font-weight: bold; background-color: #d0d0d0; text-align: right; }
        .description-row td { font-style: italic; color: #666; }
        .amount-column { text-align: right; }
        .selected-row { background-color: #e6f7ff !important; }
        .row-checkbox { width: 18px; height: 18px; cursor: pointer; }
        .select-all-checkbox { margin-right: 5px; }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .toggle-container { display: flex; align-items: center; gap: 0.5rem; }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3b82f6;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider { background-color: #10b981; }
        input:checked + .toggle-slider:before { transform: translateX(32px); }
        .toggle-label { font-size: 0.875rem; color: #333; }
        
        .sheet-info {
            font-size: 0.75rem;
            margin-top: 0.5rem;
            padding: 0.25rem;
            background-color: #f8fafc;
            border-radius: 0.25rem;
        }
        .sheet-info-title { font-weight: 600; margin-bottom: 0.25rem; }
        .sheet-info-row { display: flex; justify-content: space-between; }
    </style>
</head>
<body class="p-4 bg-gray-100">
    <h1 class="text-2xl font-bold mb-4">G Printer</h1>
    
    <div class="bg-white p-4 rounded shadow mb-6">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <div>
                <div class="section-header">Load File</div>
                <div class="control-panel-section">
                    <input type="file" id="fileInput" accept=".xlsx" class="text-sm w-full mb-2">
                    <button id="loadFile" class="bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600 w-full text-sm flex items-center justify-center gap-2">
                        <span id="loadButtonText">Upload</span>
                        <span id="loadSpinner" class="spinner hidden"></span>
                    </button>
                    <div id="sheetInfo" class="sheet-info hidden">
                        <div class="sheet-info-title">Sheets in uploaded file:</div>
                        <div class="sheet-info-row">
                            <span>Custom Report:</span>
                            <span id="customReportRows">0 rows</span>
                        </div>
                        <div class="sheet-info-row">
                            <span>Item Details:</span>
                            <span id="itemDetailsRows">0 rows</span>
                        </div>
                        <div class="sheet-info-row">
                            <span>Merged unique Data:</span>
                            <span id="mergedDataRows">0 rows</span>
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <div class="section-header">Search</div>
                <div class="control-panel-section">
                    <select id="nameColumn" class="border p-1 rounded w-full text-sm mb-2"></select>
                    <div id="textSearchContainer">
                        <div class="combo-box">
                            <input type="text" id="nameSearchInput" placeholder="Type to search or select..." class="border p-1 rounded w-full text-sm">
                            <div id="nameSearchDropdown" class="combo-box-options"></div>
                        </div>
                    </div>
                    <div id="dateRangeContainer" class="date-range-container">
                        <div>
                            <label class="text-xs">From:</label>
                            <input type="date" id="dateFrom" class="border p-1 rounded w-full text-sm">
                        </div>
                        <div>
                            <label class="text-xs">To:</label>
                            <input type="date" id="dateTo" class="border p-1 rounded w-full text-sm">
                        </div>
                    </div>
                    <div id="dateRangeActive" class="date-range-active hidden"></div>
                    <button id="searchByName" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 mt-2 w-full text-sm">
                        Apply
                    </button>
                </div>
            </div>

            <div>
                <div class="section-header">Select columns</div>
                <div class="control-panel-section">
                    <select id="columnSelect" multiple class="border p-2 rounded w-full text-sm h-16 mb-2"></select>
                    <button id="applyFilters" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 w-full text-sm">
                        Apply & Save
                    </button>
                </div>
            </div>
        </div>

        <div class="flex flex-wrap gap-2 mt-4 items-center">
            <div class="toggle-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="printToggle">
                    <span class="toggle-slider"></span>
                </label>
                <span id="printToggleLabel" class="toggle-label">Print All</span>
            </div>
            <button id="executePrint" class="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600 text-sm">
                View & Print
            </button>
        </div>
    </div>

    <h2 class="text-xl font-semibold mt-6">Filtered Rows</h2>
    <div class="table-container">
        <table id="matchingRowsTable" class="bg-white"></table>
    </div>
    <button id="showAllRows" class="show-more-btn hidden">Show All Rows</button>

    <script>
        let data = [];
        let headers = [];
        let filteredData = [];
        let showingAllRows = false;
        let originalData = [];
        let selectedColumns = [];
        let currentSortColumn = null;
        let sortDirection = 'asc';
        let selectedRows = new Set();

        // Load Excel File
        document.getElementById('loadFile').addEventListener('click', () => {
            const file = document.getElementById('fileInput').files[0];
            if (!file) {
                alert('Please select a file.');
                return;
            }

            const loadButtonText = document.getElementById('loadButtonText');
            const loadSpinner = document.getElementById('loadSpinner');
            const loadButton = document.getElementById('loadFile');
            
            loadButton.disabled = true;
            loadButtonText.textContent = 'Processing...';
            loadSpinner.classList.remove('hidden');

            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.error || 'Network response was not ok');
                    });
                }
                return response.json();
            })
            .then(responseData => {
                if (responseData.error) {
                    throw new Error(responseData.error);
                }

                data = responseData.data || [];
                headers = responseData.headers || (data.length > 0 ? Object.keys(data[0]) : []);
                
                if (data.length === 0) {
                    throw new Error('No data found in the processed file');
                }
                
                originalData = [...data];
                filteredData = [...data];
                selectedColumns = [...headers];
                showingAllRows = false;
                currentSortColumn = null;
                sortDirection = 'asc';
                selectedRows = new Set();
                
                updateMatchingRowsTable();
                populateDropdowns();
                
                const sheetInfoDiv = document.getElementById('sheetInfo');
                sheetInfoDiv.classList.remove('hidden');
                document.getElementById('customReportRows').textContent = 
                    `${responseData.sheetStats?.customReportRows || 'N/A'} rows`;
                document.getElementById('itemDetailsRows').textContent = 
                    `${responseData.sheetStats?.itemDetailsRows || 'N/A'} rows`;
                document.getElementById('mergedDataRows').textContent = 
                    `${data.length} rows`;
                
                document.getElementById('printToggle').checked = false;
                document.getElementById('printToggleLabel').textContent = 'Print All';
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred: ' + error.message);
                
                data = [];
                headers = [];
                originalData = [];
                filteredData = [];
                selectedRows = new Set();
                updateMatchingRowsTable();
                document.getElementById('sheetInfo').classList.add('hidden');
                document.getElementById('printToggle').checked = false;
                document.getElementById('printToggleLabel').textContent = 'Print All';
            })
            .finally(() => {
                loadButton.disabled = false;
                loadButtonText.textContent = 'Upload';
                loadSpinner.classList.add('hidden');
            });
        });
        
        function populateDropdowns() {
            const nameColumn = document.getElementById('nameColumn');
            const columnSelect = document.getElementById('columnSelect');
            nameColumn.innerHTML = '';
            columnSelect.innerHTML = '';

            headers.forEach(header => {
                const option1 = document.createElement('option');
                option1.value = header;
                option1.textContent = header;
                nameColumn.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = header;
                option2.textContent = header;
                columnSelect.appendChild(option2);
                option2.selected = selectedColumns.includes(header);
            });

            nameColumn.addEventListener('change', function() {
                const selectedColumn = this.value;
                const isDateColumn = selectedColumn.toLowerCase().includes('date');
                
                const textSearchContainer = document.getElementById('textSearchContainer');
                const dateRangeContainer = document.getElementById('dateRangeContainer');
                const dateRangeActive = document.getElementById('dateRangeActive');
                
                if (isDateColumn) {
                    textSearchContainer.style.display = 'none';
                    dateRangeContainer.classList.add('active');
                    dateRangeActive.classList.add('hidden');
                    
                    document.getElementById('dateFrom').value = '';
                    document.getElementById('dateTo').value = '';
                } else {
                    textSearchContainer.style.display = 'block';
                    dateRangeContainer.classList.remove('active');
                    dateRangeActive.classList.add('hidden');
                    
                    const uniqueValues = [...new Set(originalData.map(row => 
                        row[selectedColumn] === null || row[selectedColumn] === undefined || 
                        row[selectedColumn].toString().trim() === '' ? '(Blank)' : row[selectedColumn]
                    ))].filter(val => val !== undefined);
                    
                    const dropdown = document.getElementById('nameSearchDropdown');
                    dropdown.innerHTML = '';
                    
                    uniqueValues.forEach(value => {
                        const option = document.createElement('div');
                        option.className = value === '(Blank)' ? 'combo-box-option blank-option' : 'combo-box-option';
                        option.textContent = value;
                        option.dataset.value = value === '(Blank)' ? '' : value;
                        option.addEventListener('click', () => {
                            document.getElementById('nameSearchInput').value = value === '(Blank)' ? '' : value;
                            dropdown.classList.remove('active');
                        });
                        dropdown.appendChild(option);
                    });
                    
                    const input = document.getElementById('nameSearchInput');
                    input.value = '';
                    input.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        const options = dropdown.querySelectorAll('.combo-box-option');
                        
                        options.forEach(option => {
                            const text = option.textContent.toLowerCase();
                            if (text.includes(searchTerm) || searchTerm === '') {
                                option.style.display = 'block';
                            } else {
                                option.style.display = 'none';
                            }
                        });
                        
                        dropdown.classList.add('active');
                    });
                    
                    input.addEventListener('focus', () => {
                        dropdown.classList.add('active');
                    });
                    
                    document.addEventListener('click', (e) => {
                        if (!textSearchContainer.contains(e.target)) {
                            dropdown.classList.remove('active');
                        }
                    });
                }
            });
        }

        function calculateBalanceAdjustment(row) {
            const type = (row['Type'] || row['Txn Type'] || 'Sale').toLowerCase();
            let adjustment = 0;

            if (type.includes('sale')) {
                adjustment = parseFloat(row['Balance'] || 0);
            } else if (type.includes('payment-out') || type.includes('party to party [paid]')) {
                adjustment = parseFloat(row['Paid'] || 0);
            } else if (type.includes('payment-in') || type.includes('party to party [received]')) {
                adjustment = -1 * parseFloat(row['Received'] || 0);
            } else if (type.includes('purchase') || type.includes('credit note')) {
                adjustment = -1 * parseFloat(row['Balance'] || 0);
            }

            return adjustment;
        }

        function calculateRunningBalances(data) {
            const transactions = {};
            let runningBalance = 0;

            const openingBalanceRow = data.find(row => row['Ref_No'] === 'Opening Balance');
            if (openingBalanceRow) {
                runningBalance = parseFloat(openingBalanceRow['Balance'] || 0);
            }

            data.forEach(row => {
                if (row['Ref_No'] === 'Opening Balance') return;
                
                const key = `${row['date']}_${row['Ref_No']}`;
                
                if (!transactions[key]) {
                    transactions[key] = {
                        adjustment: calculateBalanceAdjustment(row),
                        rows: []
                    };
                }
                transactions[key].rows.push(row);
            });

            const sortedKeys = Object.keys(transactions).sort((a, b) => {
                const dateA = new Date(a.split('_')[0].split('/').reverse().join('/'));
                const dateB = new Date(b.split('_')[0].split('/').reverse().join('/'));
                return dateA - dateB;
            });

            sortedKeys.forEach(key => {
                const group = transactions[key];
                runningBalance += group.adjustment;
                
                group.rows.forEach(row => {
                    row['Est. Balance'] = runningBalance;
                });
            });

            return data;
        }

        function sortData(column) {
            if (currentSortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                sortDirection = 'asc';
            }

            filteredData.sort((a, b) => {
                const valA = a[column];
                const valB = b[column];
                
                if (!isNaN(valA) && !isNaN(valB)) {
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
                
                const dateA = new Date(valA);
                const dateB = new Date(valB);
                if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                    return sortDirection === 'asc' ? dateA - dateB : dateB - dateA;
                }
                
                const strA = String(valA || '').toLowerCase();
                const strB = String(valB || '').toLowerCase();
                return sortDirection === 'asc' 
                    ? strA.localeCompare(strB) 
                    : strB.localeCompare(strA);
            });

            updateMatchingRowsTable();
        }

        function toggleRowSelection(index, checkbox) {
            const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
            if (checkbox.checked) {
                selectedRows.add(index);
                row.classList.add('selected-row');
            } else {
                selectedRows.delete(index);
                row.classList.remove('selected-row');
            }
        }

        function selectAllRows(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('#matchingRowsTable tbody input.row-checkbox');
            
            if (selectAllCheckbox.checked) {
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    const index = parseInt(checkbox.dataset.index);
                    selectedRows.add(index);
                    const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
                    row.classList.add('selected-row');
                });
            } else {
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                    const index = parseInt(checkbox.dataset.index);
                    selectedRows.delete(index);
                    const row = document.querySelector(`#matchingRowsTable tr[data-index="${index}"]`);
                    row.classList.remove('selected-row');
                });
            }
        }

        function updateMatchingRowsTable() {
    const table = document.getElementById('matchingRowsTable');
    const showAllBtn = document.getElementById('showAllRows');
    table.innerHTML = '';
    
    if (filteredData.length === 0) {
        showAllBtn.classList.add('hidden');
        return;
    }

    // First calculate running balances properly
    const dataWithBalances = calculateRunningBalances(filteredData);
    const rowsToShow = showingAllRows ? dataWithBalances : dataWithBalances.slice(0, 5);

    const thead = document.createElement('thead');
    const tr = document.createElement('tr');
    
    // Add select all checkbox column
    const thSelect = document.createElement('th');
    const selectAllCheckbox = document.createElement('input');
    selectAllCheckbox.type = 'checkbox';
    selectAllCheckbox.className = 'row-checkbox select-all-checkbox';
    selectAllCheckbox.addEventListener('change', () => selectAllRows(selectAllCheckbox));
    thSelect.appendChild(selectAllCheckbox);
    tr.appendChild(thSelect);
    
    // Add sequential number column
    const thNum = document.createElement('th');
    thNum.textContent = '#';
    thNum.className = 'sortable-header';
    tr.appendChild(thNum);
    
    const displayColumns = selectedColumns.length > 0 ? selectedColumns : headers;
    
    displayColumns.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header === 'date' ? 'Date' : header;
        th.className = 'sortable-header';
        
        if (header === currentSortColumn) {
            th.classList.add(sortDirection);
        }
        
        th.addEventListener('click', () => {
            sortData(header);
        });
        
        tr.appendChild(th);
    });
    thead.appendChild(tr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    
    // Group transactions by Ref_No and date to calculate totals correctly
    const groupedTransactions = {};
    dataWithBalances.forEach(row => {
        const key = `${row['date']}_${row['Ref_No']}`;
        if (!groupedTransactions[key]) {
            groupedTransactions[key] = {
                rows: [],
                total: 0,
                received: parseFloat(row['Received'] || 0),
                paid: parseFloat(row['Paid'] || 0),
                balance: parseFloat(row['Balance'] || 0),
                estBalance: parseFloat(row['Est. Balance'] || 0)
            };
        }
        groupedTransactions[key].rows.push(row);
        groupedTransactions[key].total += parseFloat(row['Amount'] || 0);
    });

    // Calculate the final running balance
    let finalBalance = 0;
    Object.values(groupedTransactions).forEach(group => {
        finalBalance = group.estBalance;
    });

    // Now display the rows
    let rowIndex = 0;
    Object.keys(groupedTransactions).forEach(key => {
        const group = groupedTransactions[key];
        group.rows.forEach((row, itemIndex) => {
            const tr = document.createElement('tr');
            tr.dataset.index = rowIndex;
            
            // Add checkbox for row selection
            const tdSelect = document.createElement('td');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'row-checkbox';
            checkbox.dataset.index = rowIndex;
            checkbox.addEventListener('change', (e) => toggleRowSelection(rowIndex, e.target));
            if (selectedRows.has(rowIndex)) {
                checkbox.checked = true;
                tr.classList.add('selected-row');
            }
            tdSelect.appendChild(checkbox);
            tr.appendChild(tdSelect);
            
            // Add sequential number
            const tdNum = document.createElement('td');
            tdNum.textContent = rowIndex + 1;
            tr.appendChild(tdNum);
            
            displayColumns.forEach(header => {
                const td = document.createElement('td');
                if (header === 'Amount' || header === 'Received' || header === 'Total' || 
                    header === 'Paid' || header === 'Balance' || header === 'Est. Balance') {
                    td.className = 'amount-column';
                    // For grouped rows, only show the full values on the first row
                    if (itemIndex === 0 || !['Total', 'Received', 'Paid', 'Balance', 'Est. Balance'].includes(header)) {
                        td.textContent = row[header] ? parseFloat(row[header]).toFixed(2) : '0.00';
                    } else {
                        td.textContent = ''; // Leave empty for subsequent rows of same transaction
                    }
                } else {
                    td.textContent = row[header] || '';
                }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
            rowIndex++;
        });
    });

    // Add summary rows
    const hasQuantity = displayColumns.includes('Quantity');
    const hasAmount = displayColumns.includes('Amount');
    const hasReceived = displayColumns.includes('Received');
    const hasTotal = displayColumns.includes('Total');
    const hasPaid = displayColumns.includes('Paid');

    if (hasQuantity || hasAmount || hasReceived || hasTotal || hasPaid) {
        const totalRow = document.createElement('tr');
        totalRow.className = 'total-row';
        
        const tdSelect = document.createElement('td');
        totalRow.appendChild(tdSelect);
        
        const tdNum = document.createElement('td');
        tdNum.textContent = '';
        totalRow.appendChild(tdNum);
        
        displayColumns.forEach(header => {
            const td = document.createElement('td');
            
            if (header === 'Quantity') {
                // Calculate total quantity
                let totalQty = 0;
                dataWithBalances.forEach(row => {
                    totalQty += parseFloat(row['Quantity'] || 0);
                });
                td.textContent = totalQty.toFixed(2);
            } else if (header === 'Amount') {
                // Calculate total amount
                let totalAmt = 0;
                dataWithBalances.forEach(row => {
                    totalAmt += parseFloat(row['Amount'] || 0);
                });
                td.className = 'amount-column';
                td.textContent = totalAmt.toFixed(2);
            } else {
                td.textContent = '';
            }
            
            totalRow.appendChild(td);
        });
        
        tbody.appendChild(totalRow);
    }

    // Description row
    const descRow = document.createElement('tr');
    descRow.className = 'description-row';
    const descCell = document.createElement('td');
    descCell.colSpan = displayColumns.length + 2;
    let customDescriptionText = '';
    const firstWithDescription = filteredData.find(row => row['Description_x']);
    if (firstWithDescription) {
        customDescriptionText = firstWithDescription['Description_x'];
    }
    descCell.textContent = `Description: ${customDescriptionText}`;
    descRow.appendChild(descCell);
    tbody.appendChild(descRow);

    // Sub Total and Total rows (now showing the final running balance)
    if ((hasAmount || hasTotal) && (hasReceived || hasPaid)) {
        const subtotalRow = document.createElement('tr');
        subtotalRow.className = 'subtotal-row';
        const subtotalCell = document.createElement('td');
        subtotalCell.colSpan = displayColumns.length + 1;
        subtotalCell.textContent = 'Sub Total:';
        subtotalRow.appendChild(subtotalCell);
        
        const subtotalValueCell = document.createElement('td');
        subtotalValueCell.className = 'amount-column';
        subtotalValueCell.textContent = finalBalance.toFixed(2);
        subtotalRow.appendChild(subtotalValueCell);
        tbody.appendChild(subtotalRow);

        const finalTotalRow = document.createElement('tr');
        finalTotalRow.className = 'final-total-row';
        const finalTotalCell = document.createElement('td');
        finalTotalCell.colSpan = displayColumns.length + 1;
        finalTotalCell.textContent = 'Total:';
        finalTotalRow.appendChild(finalTotalCell);
        
        const finalTotalValueCell = document.createElement('td');
        finalTotalValueCell.className = 'amount-column';
        finalTotalValueCell.textContent = finalBalance.toFixed(2);
        finalTotalRow.appendChild(finalTotalValueCell);
        tbody.appendChild(finalTotalRow);
    }
    
    table.appendChild(tbody);

    if (filteredData.length > 5 && !showingAllRows) {
        showAllBtn.classList.remove('hidden');
        showAllBtn.textContent = `Show All (${filteredData.length} rows)`;
    } else {
        showAllBtn.classList.add('hidden');
    }
}
        document.getElementById('searchByName').addEventListener('click', () => {
            const column = document.getElementById('nameColumn').value;
            const isDateColumn = column.toLowerCase().includes('date');
            
            if (isDateColumn) {
                const dateFrom = document.getElementById('dateFrom').value;
                const dateTo = document.getElementById('dateTo').value;
                
                if (!dateFrom && !dateTo) {
                    alert('Please select at least one date for the range');
                    return;
                }
                
                const dateRangeActive = document.getElementById('dateRangeActive');
                dateRangeActive.textContent = `Active range: ${dateFrom || 'Start'} to ${dateTo || 'End'}`;
                dateRangeActive.classList.remove('hidden');
                
                filteredData = originalData.filter(row => {
                    const cellValue = row[column];
                    if (!cellValue) return false;
                    
                    let cellDate;
                    if (cellValue instanceof Date) {
                        cellDate = new Date(cellValue);
                    } else if (typeof cellValue === 'string' || typeof cellValue === 'number') {
                        if (typeof cellValue === 'string' && cellValue.includes('/')) {
                            const parts = cellValue.split('/');
                            if (parts.length === 3) {
                                const day = parseInt(parts[0], 10);
                                const month = parseInt(parts[1], 10) - 1;
                                const year = parseInt(parts[2], 10);
                                cellDate = new Date(year, month, day);
                            } else {
                                cellDate = new Date(cellValue);
                            }
                        } else {
                            cellDate = new Date(cellValue);
                        }
                    } else {
                        return false;
                    }
                    
                    if (isNaN(cellDate.getTime())) return false;
                    
                    const fromDate = dateFrom ? new Date(dateFrom) : null;
                    const toDate = dateTo ? new Date(dateTo) : null;
                    
                    if (fromDate) fromDate.setHours(0, 0, 0, 0);
                    if (toDate) toDate.setHours(23, 59, 59, 999);
                    cellDate.setHours(0, 0, 0, 0);
                    
                    if (fromDate && toDate) {
                        return cellDate >= fromDate && cellDate <= toDate;
                    } else if (fromDate) {
                        return cellDate >= fromDate;
                    } else if (toDate) {
                        return cellDate <= toDate;
                    }
                    return false;
                });
            } else {
                const searchTerm = document.getElementById('nameSearchInput').value;
                filteredData = originalData.filter(row => {
                    const cellValue = row[column] || '';
                    if (searchTerm === '') {
                        return cellValue.toString().trim() === '';
                    } else {
                        return cellValue.toString() === searchTerm;
                    }
                });

                const nonEmptyColumns = new Set();
                
                headers.forEach(header => {
                    const hasData = filteredData.some(row => {
                        const value = row[header];
                        return value !== null && 
                               value !== undefined && 
                               value.toString().trim() !== '' && 
                               value !== 0 && 
                               value !== '0';
                    });
                    
                    if (hasData) {
                        nonEmptyColumns.add(header);
                    }
                });

                selectedColumns = headers.filter(header => nonEmptyColumns.has(header));
                
                const columnSelect = document.getElementById('columnSelect');
                Array.from(columnSelect.options).forEach(option => {
                    option.selected = selectedColumns.includes(option.value);
                });
                
                document.getElementById('dateRangeActive').classList.add('hidden');
            }

            currentSortColumn = null;
            sortDirection = 'asc';
            showingAllRows = false;
            selectedRows = new Set();
            document.getElementById('printToggle').checked = false;
            document.getElementById('printToggleLabel').textContent = 'Print All';
            updateMatchingRowsTable();
        });

        document.getElementById('showAllRows').addEventListener('click', () => {
            showingAllRows = true;
            updateMatchingRowsTable();
        });

        document.getElementById('applyFilters').addEventListener('click', () => {
            selectedColumns = Array.from(document.getElementById('columnSelect').selectedOptions).map(opt => opt.value);
            
            if (selectedColumns.length === 0) {
                selectedColumns = [...headers];
            }
            
            showingAllRows = false;
            updateMatchingRowsTable();
        });

        document.getElementById('printToggle').addEventListener('change', function() {
            document.getElementById('printToggleLabel').textContent = this.checked ? 'Print Selected' : 'Print All';
        });

        document.getElementById('executePrint').addEventListener('click', () => {
            const printToggle = document.getElementById('printToggle');
            
            if (printToggle.checked) {
                if (selectedRows.size === 0) {
                    alert('No rows selected. Please select rows to print.');
                    return;
                }
                const selectedData = Array.from(selectedRows).map(index => filteredData[index]);
                prepareAndOpenPrintView(selectedData);
            } else {
                if (filteredData.length === 0) {
                    alert('No filtered data available. Please apply filters first.');
                    return;
                }
                prepareAndOpenPrintView(filteredData);
            }
        });

        function prepareAndOpenPrintView(dataToPrint) {
            const displayColumns = selectedColumns.length > 0 ? selectedColumns : headers;
            
            const partyRow = dataToPrint.find(row => row['Party Name_y']);
            let partyInfo = { name: '', mobile: '' };
            
            if (partyRow) {
                const partyString = partyRow['Party Name_y'];
                const mobileMatch = partyString.match(/\d{10}/);
                partyInfo.mobile = mobileMatch ? mobileMatch[0] : '';
                
                partyInfo.name = partyString.replace(/\(.*\d{10}.*\)/, '').trim();
                if (!partyInfo.name) {
                    partyInfo.name = partyString.replace(/\d{10}/, '').replace(/[()]/g, '').trim();
                }
            }
            
            const dateRange = { from: '', to: '' };
            const dateFromInput = document.getElementById('dateFrom');
            const dateToInput = document.getElementById('dateTo');
            
            if (dateFromInput.value || dateToInput.value) {
                if (dateFromInput.value) {
                    const [y, m, d] = dateFromInput.value.split('-');
                    dateRange.from = `${d}/${m}/${y}`;
                }
                if (dateToInput.value) {
                    const [y, m, d] = dateToInput.value.split('-');
                    dateRange.to = `${d}/${m}/${y}`;
                }
            } else {
                const dates = dataToPrint.map(row => {
                    if (row.date) {
                        const [d, m, y] = row.date.split('/');
                        return new Date(`${y}-${m}-${d}`);
                    }
                    return null;
                }).filter(date => date);
                
                if (dates.length > 0) {
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    
                    dateRange.from = `${String(minDate.getDate()).padStart(2, '0')}/${String(minDate.getMonth() + 1).padStart(2, '0')}/${minDate.getFullYear()}`;
                    dateRange.to = `${String(maxDate.getDate()).padStart(2, '0')}/${String(maxDate.getMonth() + 1).padStart(2, '0')}/${maxDate.getFullYear()}`;
                }
            }
            
            sessionStorage.setItem('filteredData', JSON.stringify(dataToPrint));
            sessionStorage.setItem('columnsToShow', JSON.stringify(displayColumns));
            sessionStorage.setItem('dateRange', JSON.stringify(dateRange));
            sessionStorage.setItem('partyInfo', JSON.stringify(partyInfo));
            
            setTimeout(() => {
                const printWindow = window.open('/print', '_blank');
                if (!printWindow) {
                    alert('Popup blocked. Please allow popups for this site.');
                }
            }, 100);
        }
    </script>
</body>
</html>