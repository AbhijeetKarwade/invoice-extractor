<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Invoice Report</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 10px;
            font-size: 10pt;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        .header-item {
            font-weight: bold;
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 10px;
            table-layout: fixed;
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 4px; 
            text-align: left; 
            font-size: 9pt;
        }
        th { 
            background-color: #d3d3d3; 
            color: black;
            position: sticky;
            top: 0;
        }
        button { 
            padding: 10px; 
            margin: 5px; 
            background-color: #3b82f6; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
        }
        button:hover { 
            background-color: #2563eb; 
        }
        .total-row td {
            font-weight: bold;
            background-color: #f0f0f0;
        }
        .subtotal-row td {
            font-weight: bold;
            background-color: #d3d3d3;
            text-align: right;
            color: black;
        }
        .final-total-row td {
            font-weight: bold;
            background-color: #d3d3d3;
            text-align: right;
            color: black;
        }
        .description-row {
            font-style: italic;
            color: #666;
            padding: 4px 0 4px 30px;
            background-color: #f9f9f9;
            margin-top: 5px;
        }
        .item-table {
            margin: 10px 0 5px 30px;
            width: calc(100% - 30px);
            table-layout: fixed;
            border: 1px solid #ddd;
        }
        .item-table th, .item-table td {
            padding: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            border: 1px solid #ddd;
        }
        .item-table th {
            background-color: #d3d3d3;
            color: black;
        }
        .item-details-label {
            padding-left: 30px;
            font-style: italic;
            margin-top: 10px;
        }
        .summary-table {
            width: 100%;
            margin-top: 10px;
            table-layout: fixed;
        }
        .summary-table td {
            border: 1px solid #ddd;
            padding: 6px;
        }
        .amount-column {
            text-align: right;
        }
        .duration-row {
            margin-top: 3px;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        /* Transaction Group Styling */
        .transaction-group {
            margin-bottom: 10px;
            page-break-inside: avoid;
        }
        .transaction-separator {
            margin: 5px 0;
            border-top: 1px dashed #999;
        }
        
        /* Column Widths */
        #mainHeaderTable th:nth-child(1),
        .header-table td:nth-child(1) { width: 8%; }
        #mainHeaderTable th:nth-child(2),
        .header-table td:nth-child(2) { width: 10%; }
        #mainHeaderTable th:nth-child(3),
        .header-table td:nth-child(3) { width: 15%; }
        #mainHeaderTable th:nth-child(4),
        .header-table td:nth-child(4) { width: 10%; }
        #mainHeaderTable th:nth-child(5),
        .header-table td:nth-child(5) { width: 10%; }
        #mainHeaderTable th:nth-child(6),
        .header-table td:nth-child(6) { width: 10%; }
        #mainHeaderTable th:nth-child(7),
        .header-table td:nth-child(7) { width: 10%; }
        #mainHeaderTable th:nth-child(8),
        .header-table td:nth-child(8) { width: 12%; }
        
        /* Item table column widths */
        .item-table th:nth-child(1) { width: 5%; }
        .item-table th:nth-child(2) { width: 25%; }
        .item-table th:nth-child(3) { width: 10%; }
        .item-table th:nth-child(4) { width: 10%; }
        .item-table th:nth-child(5) { width: 10%; }
        .item-table th:nth-child(6) { width: 15%; }
        .item-table th:nth-child(7) { width: 15%; }
        
        @media print {
            @page {
                margin: 6mm;
            }
            button { 
                display: none; 
            }
            body { 
                margin: 0; 
                padding: 0;
            }
            .header-container {
                margin-bottom: 10px;
                padding-bottom: 5px;
            }
            .duration-row {
                margin-bottom: 3px;
            }
            .transaction-group {
                page-break-inside: avoid;
            }
            th {
                position: static;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: #d3d3d3 !important;
            }
            .item-table th {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: #d3d3d3 !important;
            }
            .subtotal-row td {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: #d3d3d3 !important;
            }
            .final-total-row td {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: #d3d3d3 !important;
            }
        }
    </style>
</head>
<body>
    <div class="header-container">
        <div class="header-item"><span id="partyName"></span></div>
        <div class="header-item"><span id="contactNo"></span></div>
    </div>
    <div class="duration-row"><span id="duration"></span></div>

    <!-- Single set of column headers at the top -->
    <table id="mainHeaderTable">
        <thead>
            <tr>
                <th>Date</th>
                <th>Txn Type</th>
                <th>Ref No.</th>
                <th>Total</th>
                <th>Received/Paid</th>
                <th>Txn Balance</th>
                <th>Open. Balance</th>
                <th>Est. Balance</th>
            </tr>
        </thead>
    </table>

    <div id="transactionContainer"></div>

    <table class="summary-table">
        <tbody id="summaryRows"></tbody>
    </table>

    <div class="button-container">
        <button id="printButton">Print</button>
        <button onclick="window.location.href='/'">Back to Home</button>
    </div>

    <script>
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Format values for display
            function formatValue(value) {
                if (value === null || value === undefined || value === '') {
                    return '0.00';
                }
                
                if (!isNaN(value) && value !== '') {
                    return parseFloat(value).toFixed(2);
                }
                
                return value || '0.00';
            }

            // Format reference number to remove .00 if present
            function formatRefNo(refNo) {
                if (!refNo || refNo === 'N/A') return 'N/A';
                return refNo.toString().replace(/\.00$/, '');
            }

            function extractPartyInfo(row) {
                if (!row) return { name: '', mobile: '' };

                // Prefer name from Party Name_x if present, else from Party Name_y
                const nameString = row['Party Name_x'] || row['Party Name_y'] || '';

                // For mobile number, check both fields
                const combinedPartyString = [row['Party Name_x'], row['Party Name_y']]
                    .filter(Boolean) // remove undefined/null
                    .join(' ');
                const mobileMatch = combinedPartyString.match(/\d{10}/);
                const mobile = mobileMatch ? mobileMatch[0] : '';

                // Clean the name (remove mobile numbers or parentheses)
                let name = nameString.replace(/\(.*\d{10}.*\)/, '').trim();
                if (!name) {
                    name = nameString.replace(/\d{10}/, '').replace(/[()]/g, '').trim();
                }

                return { name, mobile };
}

            // Format date for display
            function formatDate(dateStr) {
                if (!dateStr) return 'Na';
                return dateStr;
            }

            // Calculate payment value from row
            function getPaymentValue(row) {
                return parseFloat(row['Received'] || row['Paid'] || 0);
            }
            
            // Calculate balance adjustment based on transaction type
            function calculateBalanceAdjustment(row) {
                const type = (row['Txn Type'] || row['Type'] || 'Sale').toLowerCase();
                let adjustment = 0;

                if (type.includes('sale')) {
                    adjustment = parseFloat(row['Balance'] || 0);
                } else if (type.includes('payment-out') || type.includes('party to party [paid]')) {
                    adjustment = parseFloat(row['Paid'] || 0);
                } else if (type.includes('payment-in') || type.includes('party to party [received]')) {
                    adjustment = -1 * parseFloat(row['Received'] || 0);
                } else if (type.includes('purchase') || type.includes('credit note')) {
                    adjustment = -1 * parseFloat(row['Balance'] || 0);
                }

                return adjustment;
            }
            
            // Create a transaction group element with multiple items
            function createTransactionGroup(txn, runningBalance) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'transaction-group';
                
                // Calculate O. Balance = Est. Balance - Txn Balance
                const oBalance = (runningBalance - parseFloat(txn.balance || 0)).toFixed(2);
                
                // Transaction row
                const headerTable = document.createElement('table');
                headerTable.className = 'header-table';
                
                const headerBody = document.createElement('tbody');
                headerBody.innerHTML = `
                    <tr>
                        <td>${formatDate(txn.date)}</td>
                        <td>${formatValue(txn.type)}</td>
                        <td>${formatRefNo(txn.refNo)}</td>
                        <td>${formatValue(txn.amount)}</td>
                        <td>${formatValue(txn.payment)}</td>
                        <td>${formatValue(txn.balance)}</td>
                        <td>${formatValue(txn.openBalance || oBalance)}</td>
                        <td>${formatValue(txn.estBalance || runningBalance)}</td>
                    </tr>
                `;
                headerTable.appendChild(headerBody);
                groupDiv.appendChild(headerTable);
                
                // Item details if available
                if (txn.items && txn.items.length > 0) {
                    const detailsLabel = document.createElement('div');
                    detailsLabel.className = 'item-details-label';
                    groupDiv.appendChild(detailsLabel);
                    
                    const itemTable = document.createElement('table');
                    itemTable.className = 'item-table';
                    
                    const itemThead = document.createElement('thead');
                    itemThead.innerHTML = `
                        <tr>
                            <th>#</th>
                            <th>Item name</th>
                            <th>Size</th>
                            <th>Quantity</th>
                            <th>Unit</th>
                            <th>Price/Unit</th>
                            <th class="amount-column">Amount</th>
                        </tr>
                    `;
                    itemTable.appendChild(itemThead);
                    
                    const itemTbody = document.createElement('tbody');
                    
                    // Add each item as a row
                    txn.items.forEach((item, index) => {
                        const itemRow = document.createElement('tr');
                        itemRow.innerHTML = `
                            <td>${index + 1}</td>
                            <td>${formatValue(item.itemName)}</td>
                            <td>${formatValue(item.size)}</td>
                            <td>${formatValue(item.quantity)}</td>
                            <td>${formatValue(item.unit)}</td>
                            <td>${formatValue(item.price)}</td>
                            <td class="amount-column">${formatValue(item.amount)}</td>
                        `;
                        itemTbody.appendChild(itemRow);
                    });
                    
                    // Add total row
                    const totalRow = document.createElement('tr');
                    totalRow.className = 'total-row';
                    totalRow.innerHTML = `
                        <td colspan="3">Total</td>
                        <td>${formatValue(txn.totalQuantity)}</td>
                        <td colspan="2"></td>
                        <td class="amount-column">${formatValue(txn.amount)}</td>
                    `;
                    itemTbody.appendChild(totalRow);
                    
                    itemTable.appendChild(itemTbody);
                    groupDiv.appendChild(itemTable);
                }
                
                // Add description if available - now checking Description, Description_x, and Description_y
                const description = txn.description || txn.description_x || txn.description_y;
                if (description) {
                    const descDiv = document.createElement('div');
                    descDiv.className = 'description-row';
                    descDiv.textContent = `Description: ${description}`;
                    groupDiv.appendChild(descDiv);
                }
                
                // Add separator
                const separator = document.createElement('div');
                separator.className = 'transaction-separator';
                groupDiv.appendChild(separator);
                
                return groupDiv;
            }

            // Function to group transactions by date, refNo, and party
            function groupTransactions(rows) {
                const grouped = {};
                
                rows.forEach(row => {
                    if (row['Ref_No'] === 'Opening Balance') return;
                    
                    const key = `${row['date']}_${row['Ref_No']}_${row['Party Name_y'] || row['Party Name_x']}`;
                    
                    if (!grouped[key]) {
                        grouped[key] = {
                            date: row['date'],
                            type: row['Txn Type'] || row['Type'] || 'Sale',
                            refNo: formatRefNo(row['Ref_No'] || 'N/A'),
                            amount: 0,
                            payment: 0,
                            balance: 0, // This will be calculated based on type
                            openBalance: row['Open. Balance'], // Preserve pre-calculated value
                            estBalance: row['Est. Balance'], // Preserve pre-calculated value
                            description: row['Description'] || row['Description_x'] || row['Description_y'],
                            description_x: row['Description_x'],
                            description_y: row['Description_y'],
                            items: [],
                            totalQuantity: 0
                        };
                    }
                    
                    // Calculate balance adjustment based on transaction type
                    grouped[key].balance = calculateBalanceAdjustment(row);
                    grouped[key].amount += parseFloat(row['Amount'] || 0);
                    // Add to amounts (only once per transaction)
                    if (!grouped[key].payment || grouped[key].payment === 0) {
                        grouped[key].payment = parseFloat(row['Received'] || row['Paid'] || 0);
                    }

                    
                    // Add item details if available
                    if (row['Item Name'] || row['Quantity']) {
                        grouped[key].items.push({
                            itemName: row['Item Name'],
                            size: row['Size'],
                            quantity: row['Quantity'],
                            unit: row['Unit'],
                            price: row['Price/ Unit'] || row['UnitPrice'],
                            amount: row['Amount'] || row['Amount']
                        });
                        
                        grouped[key].totalQuantity += parseFloat(row['Quantity'] || 0);
                    }
                    
                    // Keep the first description found (checking all three possible description fields)
                    if (!grouped[key].description) {
                        grouped[key].description = row['Description'] || row['Description_x'] || row['Description_y'];
                    }
                });
                
                return Object.values(grouped);
            }

            // Function to calculate running balances for all transactions
            function calculateRunningBalances(transactions) {
                let runningBalance = 0;
                const balances = {};
                
                // Find opening balance if exists
                const openingBalanceRow = transactions.find(row => row['Ref_No'] === 'Opening Balance');
                if (openingBalanceRow) {
                    runningBalance = parseFloat(openingBalanceRow['Balance'] || 0);
                    balances[`${openingBalanceRow.date}_Opening Balance`] = runningBalance;
                }
                
                // Group transactions by date and Ref_No to calculate balances correctly
                const transactionGroups = {};
                transactions.forEach(row => {
                    if (row['Ref_No'] === 'Opening Balance') return;
                    
                    const key = `${row['date']}_${row['Ref_No']}_${row['Party Name_y'] || row['Party Name_x']}`;
                    if (!transactionGroups[key]) {
                        transactionGroups[key] = {
                            adjustment: 0,
                            date: row['date'],
                            refNo: row['Ref_No']
                        };
                    }
                    
                    // Only add the adjustment once per transaction group
                    if (transactionGroups[key].adjustment === 0) {
                        transactionGroups[key].adjustment = calculateBalanceAdjustment(row);
                    }
                });
                
                // Convert to array and sort by date
                const sortedGroups = Object.values(transactionGroups).sort((a, b) => {
                    const dateA = a.date ? new Date(a.date.split('/').reverse().join('/')) : new Date(0);
                    const dateB = b.date ? new Date(b.date.split('/').reverse().join('/')) : new Date(0);
                    return dateA - dateB;
                });
                
                // Calculate running balances for each transaction group
                sortedGroups.forEach(group => {
                    runningBalance += group.adjustment;
                    balances[`${group.date}_${group.refNo}`] = runningBalance;
                });
                
                return balances;
            }

            // Function to load and display data
            function loadData() {
                // Get data from session storage   13/08/2025
                const filteredData = JSON.parse(sessionStorage.getItem('filteredData') || []);
                const allPartyTransactions = JSON.parse(sessionStorage.getItem('allPartyTransactions') || []);
                const dateRange = JSON.parse(sessionStorage.getItem('dateRange') || {});
                const partyInfo = JSON.parse(sessionStorage.getItem('partyInfo') || {});
                
                // Try to find a row with party info in filteredData first
                let partyRow = filteredData.find(row => row['Party Name_x'] || row['Party Name_y']);
                if (!partyRow && allPartyTransactions.length > 0) {
                    partyRow = allPartyTransactions.find(row => row['Party Name_x'] || row['Party Name_y']);
                }
                
                // Extract party info with priority to Party Name_x
                const extractedPartyInfo = extractPartyInfo(partyRow);
                
                // Use extracted info if available, otherwise fall back to stored partyInfo
                const finalPartyInfo = {
                    name: extractedPartyInfo.name || partyInfo.name || 'Na',
                    mobile: extractedPartyInfo.mobile || partyInfo.mobile || 'Na'
                };
                
                // Set header information
                document.getElementById('partyName').textContent = finalPartyInfo.name;
                document.getElementById('contactNo').textContent = finalPartyInfo.mobile;
                
                // Rest of the function remains the same...
                // Always show the full date range for the party, not the filtered range
                const partyName = finalPartyInfo.name || 'Na';
                let fullPartyDateRange = { from: 'N/A', to: 'N/A' };
                
                if (partyName !== 'Na') {
                    const partyTransactions = allPartyTransactions;
                    
                    if (partyTransactions.length > 0) {
                        const dates = partyTransactions
                            .map(row => row.date ? new Date(row.date.split('/').reverse().join('/')) : null)
                            .filter(date => date && !isNaN(date.getTime()));
                        
                        if (dates.length > 0) {
                            const minDate = new Date(Math.min(...dates));
                            const maxDate = new Date(Math.max(...dates));
                            
                            fullPartyDateRange.from = `${String(minDate.getDate()).padStart(2, '0')}/${String(minDate.getMonth() + 1).padStart(2, '0')}/${minDate.getFullYear()}`;
                            fullPartyDateRange.to = `${String(maxDate.getDate()).padStart(2, '0')}/${String(maxDate.getMonth() + 1).padStart(2, '0')}/${maxDate.getFullYear()}`;
                        }
                    }
                }
                
                document.getElementById('duration').textContent = 
                    ` ${fullPartyDateRange.from || 'Na'} - ${fullPartyDateRange.to || 'Na'}`;

                const transactionContainer = document.getElementById('transactionContainer');
                const summaryRowsContainer = document.getElementById('summaryRows');
                
                if (filteredData.length === 0) {
                    transactionContainer.innerHTML = '<p>No transaction data available.</p>';
                    return;
                }

                // Calculate running balances for all party transactions
                const allBalances = calculateRunningBalances(allPartyTransactions);
                
                // Group filtered transactions
                const filteredGroupedTransactions = groupTransactions(filteredData);
                
                // Sort filtered transactions by date to display in chronological order
                filteredGroupedTransactions.sort((a, b) => {
                    const dateA = a.date ? new Date(a.date.split('/').reverse().join('/')) : new Date(0);
                    const dateB = b.date ? new Date(b.date.split('/').reverse().join('/')) : new Date(0);
                    return dateA - dateB;
                });
                
                // Add each filtered transaction with correct running balance
                let lastEstBalance = 0;
                filteredGroupedTransactions.forEach(txn => {
                    // Find the balance for this transaction
                    const balanceKey = `${txn.date}_${txn.refNo}`;
                    const runningBalance = allBalances[balanceKey] || 0;
                    lastEstBalance = runningBalance;
                    
                    const transactionGroup = createTransactionGroup(txn, runningBalance);
                    transactionContainer.appendChild(transactionGroup);
                });

                // Add summary rows using the last Est. Balance value
                const subtotalRow = document.createElement('tr');
                subtotalRow.className = 'subtotal-row';
                subtotalRow.innerHTML = `
                    <td colspan="7"></td>
                    <td class="amount-column">Sub Total: ${lastEstBalance.toFixed(2)}</td>
                `;
                summaryRowsContainer.appendChild(subtotalRow);

                const finalTotalRow = document.createElement('tr');
                finalTotalRow.className = 'final-total-row';
                finalTotalRow.innerHTML = `
                    <td colspan="7"></td>
                    <td class="amount-column">Total: ${lastEstBalance.toFixed(2)}</td>
                `;
                summaryRowsContainer.appendChild(finalTotalRow);
            }

            // Add event listeners
            document.getElementById('printButton').addEventListener('click', function() {
                window.print();
            });

            // Load and display the data
            loadData();
        });
    </script>
</body>
</html>